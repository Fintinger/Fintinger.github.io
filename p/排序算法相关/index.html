<!DOCTYPE html>
<html lang="en">
<head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='排序算法 平均时间复杂度 空间复杂度 稳定性 适用情况     插入排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   希尔排序 $O(n^{1.3})$ O(1) 不稳定    冒泡排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   快速排序 $O(n\log_2n)$ $O(nlog_2n)$ 不稳定 初始序列无序   简单选择排序 $O(n^2)$ O(1) 不稳定 n较小   堆排序 $O(n\log_2n)$ O(1) 不稳定 n较大或只排前几位   2-路归并排序 $O(n\log_2n)$ O(n) 稳定 n很大   链式基数排序 $O(d(n&#43;rd))$ $O(rd)$ 稳定 n大，关键字值小    相关概念 1.'><title>排序算法相关</title>
<link rel='canonical' href='https://www.fintinger.site/p/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/'>
<link rel="stylesheet" href="/scss/loadingPage.css">


<link rel="stylesheet" href="/scss/style.min.css">

<link rel="stylesheet" href="/scss/external/tailwind.min.css"><meta property='og:title' content='排序算法相关'>
<meta property='og:description' content='排序算法 平均时间复杂度 空间复杂度 稳定性 适用情况     插入排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   希尔排序 $O(n^{1.3})$ O(1) 不稳定    冒泡排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   快速排序 $O(n\log_2n)$ $O(nlog_2n)$ 不稳定 初始序列无序   简单选择排序 $O(n^2)$ O(1) 不稳定 n较小   堆排序 $O(n\log_2n)$ O(1) 不稳定 n较大或只排前几位   2-路归并排序 $O(n\log_2n)$ O(n) 稳定 n很大   链式基数排序 $O(d(n&#43;rd))$ $O(rd)$ 稳定 n大，关键字值小    相关概念 1.'>
<meta property='og:url' content='https://www.fintinger.site/p/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/'>
<meta property='og:site_name' content='Archai &#39;s blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='数据结构' /><meta property='article:tag' content='冒泡排序' /><meta property='article:tag' content='选择排序' /><meta property='article:tag' content='插入排序' /><meta property='article:tag' content='快速排序' /><meta property='article:tag' content='归并排序' /><meta property='article:tag' content='计数排序' /><meta property='article:tag' content='希尔排序' /><meta property='article:tag' content='堆排序' /><meta property='article:published_time' content='2021-06-10T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2021-06-10T00:00:00&#43;00:00'/><meta property='og:image' content='https://picsum.photos/seed/paixu/640/360' />
<meta name="twitter:title" content="排序算法相关">
<meta name="twitter:description" content="排序算法 平均时间复杂度 空间复杂度 稳定性 适用情况     插入排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   希尔排序 $O(n^{1.3})$ O(1) 不稳定    冒泡排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序   快速排序 $O(n\log_2n)$ $O(nlog_2n)$ 不稳定 初始序列无序   简单选择排序 $O(n^2)$ O(1) 不稳定 n较小   堆排序 $O(n\log_2n)$ O(1) 不稳定 n较大或只排前几位   2-路归并排序 $O(n\log_2n)$ O(n) 稳定 n很大   链式基数排序 $O(d(n&#43;rd))$ $O(rd)$ 稳定 n大，关键字值小    相关概念 1."><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://picsum.photos/seed/paixu/640/360' />
    <link rel="shortcut icon" href="https://gitee.com/fintinger/figure-bed/raw/master//images/20210530080206.ico" />

</head>
<body style="overflow-y: hidden" class="
    article-page has-toc
">

<div style="background:url('https://gitee.com/fintinger/figure-bed/raw/master//images/20210821130928.jpg') center/cover;"
     class="welcome_page w-full h-screen shadow-2xl flex flex-col justify-center items-center">
    <div style="user-select: none"
         class="h-max xl:w-max py-10 xl:py-32 px-32 xl:px-96 bg-gray-100 rounded-2xl shadow-2xl  flex flex-col justify-center relative mb-10">
        <span class="absolute w-16 h-16 bg-purple-200 bg-opacity0 top-14 right-14 rounded-full text-center border-2 border-purple-600 border-opacity-10 leading-loose text-3xl animate-pulse">😋</span>
        <div class="flex flex-col items-center space-y-8 font-sans">
            <div style="background: url('https://gitee.com/fintinger/figure-bed/raw/master//images/20210803221048.jpeg') center/cover"
                 class="w-44 h-44 rounded-full"></div>
            <h1 class="text-6xl font-semibold">ARCHAI</h1>
            <p style="margin-top: 7px" class="text-xl text-gray-500">Undergraduate / Rookie</p>
            <div class="bg-purple-600 px-5 py-3 rounded-md cursor-pointer"><a href="#main_content"
                                                                class="text-white hover:text-white">Read more</a></div>
        </div>
    </div>
    <footer class="h-1/5 flex flex-col justify-end ">
        <a href="#main_content">
            <svg class="animate-bounce" t="1629475731927" class="icon" viewBox="0 0 1024 1024" version="1.1"
                 xmlns="http://www.w3.org/2000/svg" p-id="2357" width="80" height="80">
                <path d="M896.32 336.992 523.648 709.664c-0.064 0.064-0.16 0.064-0.192 0.128-0.064 0.064-0.064 0.128-0.128 0.192-2.752 2.752-6.304 4.032-9.952 4.32-0.48 0.032-0.896 0.256-1.376 0.256-0.48 0-0.896-0.192-1.376-0.256-3.648-0.288-7.2-1.568-9.952-4.32-0.064-0.064-0.064-0.128-0.128-0.192-0.064-0.064-0.16-0.064-0.192-0.128L127.68 336.992c-6.432-6.432-6.592-16.704-0.32-22.976 6.24-6.24 16.512-6.112 22.976 0.32L512 676.064 873.696 314.368c6.432-6.432 16.704-6.592 22.976-0.32C902.912 320.288 902.752 330.56 896.32 336.992z"
                      p-id="2358" fill="#dbdbdb"></path>
            </svg>
        </a>
    </footer>
</div>

<div class="loading-page w-full h-full z-50 fixed top-0 text-purple-900 flex justify-center items-center">
    <div class="load-3">
        <div class="line"></div>
        <div class="line"></div>
        <div class="line"></div>
    </div>
</div>
<div id="main_content" class="main_content">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="https://www.fintinger.site" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
    <div class="article-image">
        <a href="/p/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/">
            
            <img src="https://picsum.photos/seed/paixu/640/360" loading="lazy" alt="Featured image of post 排序算法相关" />
            
        </a>
    </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E5%90%8E%E7%AB%AF/" >
                后端
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/">排序算法相关</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jun 10, 2021</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    3 min read
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>适用情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入排序</td>
<td>$O(n^2)$</td>
<td>O(1)</td>
<td>稳定</td>
<td>n较小，初始序列基本有序</td>
</tr>
<tr>
<td>希尔排序</td>
<td>$O(n^{1.3})$</td>
<td>O(1)</td>
<td>不稳定</td>
<td></td>
</tr>
<tr>
<td>冒泡排序</td>
<td>$O(n^2)$</td>
<td>O(1)</td>
<td>稳定</td>
<td>n较小，初始序列基本有序</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O(n\log_2n)$</td>
<td>$O(nlog_2n)$</td>
<td>不稳定</td>
<td>初始序列无序</td>
</tr>
<tr>
<td>简单选择排序</td>
<td>$O(n^2)$</td>
<td>O(1)</td>
<td>不稳定</td>
<td>n较小</td>
</tr>
<tr>
<td>堆排序</td>
<td>$O(n\log_2n)$</td>
<td>O(1)</td>
<td>不稳定</td>
<td>n较大或只排前几位</td>
</tr>
<tr>
<td>2-路归并排序</td>
<td>$O(n\log_2n)$</td>
<td>O(n)</td>
<td>稳定</td>
<td>n很大</td>
</tr>
<tr>
<td>链式基数排序</td>
<td>$O(d(n+rd))$</td>
<td>$O(rd)$</td>
<td>稳定</td>
<td>n大，关键字值小</td>
</tr>
</tbody>
</table>
<!-- more -->
<h2 id="相关概念">相关概念</h2>
<h3 id="1评价指标">1.评价指标</h3>
<p>时间复杂度，空间复杂度，算法的<strong>稳定性</strong></p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210606155832.png" alt=""  /></p>
<h3 id="2分类">2.分类</h3>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210606155837.png" alt=""  /></p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210610164946.png" alt=""  /></p>
<h2 id="插入排序">插入排序</h2>
<h3 id="1算法思想">1.算法思想</h3>
<p>每次将⼀个待排序的记录按其关键字⼤⼩插⼊到前⾯已排好序的⼦序列中， 直到全部记录插⼊完成。</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210610115037.gif" alt="图片来自CSDN@非晚非晚"  /></p>
<h3 id="2代码实现">2.代码实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//递增排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">InsertSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span><span class="c1">//长度为n的int型数组
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">temp</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span><span class="c1">//如果A[i]的小于其前驱则进行A[i]的移动
</span><span class="c1"></span>            <span class="n">temp</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="c1">//临时保存A[i]
</span><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">temp</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span><span class="c1">//依次检查A[i]之前已经排好序的元素
</span><span class="c1"></span>                <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="c1">//大于temp的后移
</span><span class="c1"></span>            <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span><span class="c1">//最终复制到插入位置
</span><span class="c1"></span>        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="3优化思路">3.优化思路</h3>
<p><strong>折半插入排序</strong>——先用折半查找找到应该插入的位置，再进行移动元素。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">InsertSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">,</span><span class="n">mid</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">low</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="c1">//折半查找的范围
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">low</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="o">&gt;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="n">high</span><span class="o">=</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="c1">//查找左部分
</span><span class="c1"></span>            <span class="k">else</span> <span class="n">low</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="c1">//查找右部分
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&gt;=</span><span class="n">high</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span><span class="c1">//i之前元素全部后移
</span><span class="c1"></span>            <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="c1">//插入
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><strong>注意：</strong>  一直到low&gt;high时才停止折半查找当mid所指元素等于当前元素时，应继续令low=mid+1，以保证<u>“稳定性“</u>。最终应将当前元素插入到low所指位置（即high+1）</p>
<h2 id="希尔排序">希尔排序</h2>
<h3 id="1算法思想-1">1.算法思想</h3>
<p>先将待排序表分割成若干形如 {i,i+d,i+2d, &hellip; , i+kd} 的“特殊”子表，对各个子表分别进行直接插入排序。缩小增量d(建议缩小一半)，重复上述过程，直到d=1为止。</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210610115346.png" alt="图片来自CSDN@非晚非晚"  /></p>
<h3 id="2代码实现-1">2.代码实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">ShellSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">d</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">d</span> <span class="o">=</span> <span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="c1">//步长不断衰减
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">//遍历各步长为d的子表,从子表第二个元素开始处理即可
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">]){</span><span class="c1">//如果发现逆序
</span><span class="c1"></span>                <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="c1">//暂存需要交换位置的A[i]
</span><span class="c1"></span>                <span class="k">for</span> <span class="p">(</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="n">d</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="n">j</span><span class="o">-=</span><span class="n">d</span><span class="p">)</span> <span class="c1">//当子表中存在元素，判断与A[i]大小，寻找A[i]插入位置
</span><span class="c1"></span>                    <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">d</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">];</span><span class="c1">//子表记录后移
</span><span class="c1"></span>                <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">d</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="c1">//插入
</span><span class="c1"></span>            <span class="p">}</span><span class="c1">//if
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h2 id="冒泡排序">冒泡排序</h2>
<h3 id="1算法思想-2">1.算法思想</h3>
<p>从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]&gt;A[i]），则交换它们，直到整个序列比较完毕。</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210610114840.gif" alt="图片来自CSDN@非晚非晚"  /></p>
<h3 id="2代码实现-2">2.代码实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">a</span><span class="p">;</span>
    <span class="n">a</span><span class="o">=</span><span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">BubbleSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">//i之前的所有元素必然已经有序
</span><span class="c1"></span>        <span class="kt">bool</span> <span class="n">flag</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="c1">//从后往前的一趟冒泡
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span><span class="c1">//逆序,(相等不会交换，是稳定的)
</span><span class="c1"></span>                <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
                <span class="n">flag</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span><span class="c1">//if
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span><span class="c1">//本趟遍历flag未改变，说明已经有序,可能会提前结束
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span><span class="c1">//for
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h2 id="快速排序">快速排序</h2>
<h3 id="1算法思想-3">1.算法思想</h3>
<p>在待排序表L[1&hellip;n]中<span style="background:#fff006">任取一个元素 pivot作为枢轴</span>（或基准，通常取首元素），通过一趟排序将待排序表<span style="background:#fff006">划分为独立的两部分</span>L[1&hellip;k-1]和L[k+1&hellip;n]使得L[1&hellip;k-1]中的所有元素小于pivot，L[k+1&hellip;n]中的所有元素大于等于pivot，则 pivot放在了其最终位置L[k]上这个过程称为一次“划分”。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210610115122.gif" alt="图片来自CSDN@非晚非晚"  /></p>
<h3 id="2代码实现-3">2.代码实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span><span class="kt">int</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span><span class="c1">//快速排序
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">)</span> <span class="p">{</span><span class="c1">//递归跳出的条件
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">pivotpos</span><span class="o">=</span><span class="n">Partition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">);</span><span class="c1">//进行“划分”
</span><span class="c1"></span>        <span class="n">QuickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">pivotpos</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="c1">//处理左子表
</span><span class="c1"></span>        <span class="n">QuickSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">pivotpos</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="p">);</span><span class="c1">//处理右子表
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">Partition</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span><span class="kt">int</span> <span class="n">high</span><span class="p">){</span><span class="c1">//&#34;划分&#34;函数，返回 枢轴 位置
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">pivot</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">];</span><span class="c1">//取low作为枢轴
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">)</span> <span class="p">{</span><span class="c1">//用low,high搜寻枢轴位置
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">]</span><span class="o">&gt;</span><span class="n">pivot</span><span class="p">)</span> <span class="n">high</span><span class="o">--</span><span class="p">;</span>
        <span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">];</span><span class="c1">//比枢轴小的元素移动到左端
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span> <span class="o">&amp;&amp;</span> <span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="o">&lt;</span><span class="n">pivot</span><span class="p">)</span> <span class="n">low</span><span class="o">++</span><span class="p">;</span>
        <span class="n">A</span><span class="p">[</span><span class="n">high</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">];</span><span class="c1">//比枢轴大的元素移动到右端
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">A</span><span class="p">[</span><span class="n">low</span><span class="p">]</span><span class="o">=</span><span class="n">pivot</span><span class="p">;</span><span class="c1">//改变枢轴low位置
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">low</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="3优化思路-1">3.优化思路</h3>
<p>枢轴的选择会直接影响快速排序算法的效率，因此<span style="color:#e01">优化应该从枢轴的选择角度考虑</span>。</p>
<p>① 选择首、中、尾三个位置的元素，取其中中间值作为枢轴元素。</p>
<p>② 随机选一个作为枢轴……</p>
<h3 id="4注意">4.注意</h3>
<blockquote>
<p>“一次划分” 与 “一趟排序”</p>
<ul>
<li>一次划分可以确定一个元素的最终位置</li>
<li>一趟排序也许可以确定多个元素的最终位置</li>
</ul>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210607102653.png" alt=""  /></p>
</blockquote>
<h2 id="简单选择排序">简单选择排序</h2>
<h3 id="1算法思想-4">1.算法思想</h3>
<p>每一趟在待排序元素中选取关键字最小的元素加入有序子序列</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210610115005.gif" alt="图片来自CSDN@非晚非晚"  /></p>
<h3 id="2代码实现-4">2.代码实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">a</span><span class="p">;</span>
    <span class="n">a</span><span class="o">=</span><span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">SelectSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//从头开始遍历，最后一个元素无需处理(最终一定是最大)
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">min</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="c1">//初始最小元素位置
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="c1">//在i之后所有元素中寻找最小元素位置
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">])</span> <span class="n">min</span><span class="o">=</span><span class="n">j</span><span class="p">;</span><span class="c1">//更新最小元素位置
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">min</span><span class="o">!=</span><span class="n">i</span><span class="p">)</span> <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">min</span><span class="p">],</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="c1">//将最小元素置于表头
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="堆排序">堆排序☆</h2>
<p>堆这种数据结构可以类比完全二叉树二叉树结构的顺序存储</p>
<p><img src="https://img-blog.csdnimg.cn/2021050722150754.gif#pic_center" alt=""  /></p>
<h3 id="1建立大根堆">1.建立大根堆</h3>
<p><span style="border:2px dashed #e01;padding:3px 5px">核心特性：  根≥左，右</span></p>
<h4 id="思路">思路</h4>
<p>把所有<span style="background:#fff006">非终端结点($i \leq \left \lfloor n/2 \right \rfloor$)</span>都检查一遍，是否满足大根堆的要求。</p>
<p>检查当前结点是否满足 根≥左、右，若不满足，将<span style="color:#e01">当前结点与更大的一个孩子</span>互换。</p>
<p>若<u>元素互换破坏了下一级的堆</u>，则采用相同的方法继续往下调整（小元素不断“下坠”）</p>
<h4 id="代码实现">代码实现</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">BuildMaxHeap</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="c1">//从编号最大非终端节点开始 
</span><span class="c1"></span>        <span class="n">HeadAdjust</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//调整以k为根节点的树为大根堆
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">HeadAdjust</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span><span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
    <span class="c1">//寻找A[k]应该插入的位置--“下坠”
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">*=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="o">&amp;&amp;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="c1">//找到key更大的子结点的下标
</span><span class="c1"></span>            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">break</span><span class="p">;</span><span class="c1">//满足“根”&gt;左、右，end for
</span><span class="c1"></span>        <span class="k">else</span><span class="p">{</span>
            <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="c1">//将A[i]调整到双亲结点上
</span><span class="c1"></span>            <span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span><span class="c1">//for
</span><span class="c1"></span>    <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="c1">//已找到应该插入的位置
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="2大根堆排序">2.大根堆排序</h3>
<h4 id="算法思想">算法思想</h4>
<p>利用大根堆 <u>根≥左，右</u> 的特性，</p>
<p>Step1 交换堆顶与堆底元素</p>
<p>Step2 去掉堆底元素，len-1，重新调整为大根堆结构（HeadAjust）</p>
<p>Loop step1 , step2.</p>
<h4 id="代码实现-1">代码实现</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">BuildMaxHeap</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">HeadAdjust</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">k</span><span class="p">,</span><span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">HeapSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="n">BuildMaxHeap</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">n</span><span class="p">);</span><span class="c1">//初始建立大根堆
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//n-1趟交换与建堆
</span><span class="c1"></span>        <span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="c1">//堆底与堆顶元素互换
</span><span class="c1"></span>        <span class="n">HeadAdjust</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="c1">//剩余待排序元素整理成堆
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>基于大根堆数据结构，经过排序后得到 升序序列
基于小根堆数据结构，经过排序后则会得到 降序序列</p>
</blockquote>
<h3 id="3效率分析">3.效率分析</h3>
<p><span style="border-bottom:3px solid #67b440">对于<code>BuildMaxHeap(A,n)</code></span></p>
<p>不难得出，对于一个结点，每&quot;下坠&quot;一层，最多只需对比关键字<em>2</em>次(子树之间对比，根与子树中较大的对比)</p>
<p>若树高为h，某结点在第i层，则将这个结点向下调整最多只需要&quot;下坠&quot;<em>h-i</em>层，关键字对比次数不超过<em>2(h-i)</em></p>
<p>而<em>n</em>个结点的完全二叉树树高$h=\left \lfloor \log_2n \right \rfloor+1$</p>
<p>第 i 层最多有$2^{i-1}$个结点，而只有第1~（h-1）层的结点才有可能需要“下坠”调整</p>
<p>故将整棵树调整为大根堆，关键字对比次数不超过</p>
<p>$\sum_{i=h-1}^{1} 2^{i-1} 2(h-i)=\sum_{i=h-1}^{1} 2^{i}(h-i)=\sum_{j=1}^{h-1} 2^{h-j} j \leq 2 n \sum_{j=1}^{h-1} \frac{j}{2^{j}} \leq 4 n$</p>
<p><span style="color:#e01">建堆的过程,关键字对比次数不超过4n，建堆时间复杂度=O(n)</span></p>
<p><span style="border-bottom:3px solid #67b440">对于n-1趟交换与建堆</span></p>
<p>根节点最多“下坠” h-1 层，</p>
<p>⽽每“下坠”⼀层，最多只需对⽐关键字2次，</p>
<p>因此每⼀趟排序复杂度不超过 $O(h) = O(log_2n)$ 共n-1 趟，</p>
<p>总的时间复杂度 = $O(nlog_2n)$</p>
<p>因此，</p>
<p><span style="border:2px dashed #e01;padding:3px 5px">堆排序时间复杂度=$O(n) + O(nlog_2n)=O(nlog_2n)$ </span></p>
<h3 id="4堆的插入与删除">4.堆的插入与删除</h3>
<h4 id="41-插入">4.1 插入</h4>
<p>对于小根堆，新元素放到<u>表尾</u>，与父节点对比，若<u>新元素比父节点更小，则将二者互换</u>。新元素就这样一路&quot;上升&quot;，<u>直到无法继续上升为止</u>。</p>
<h4 id="42-删除">4.2 删除</h4>
<p><span style="color:#e01">被删除的元素用堆底元素替代</span>，然后让该元素不断“下坠”，直到无法下坠为止</p>
<h2 id="归并排序">归并排序</h2>
<h3 id="1算法思想-5">1.算法思想</h3>
<p>对于一个给定的序列</p>
<p>第一趟，将每1个元素看做一个组，相邻的两组进行二路归并</p>
<p>第二趟，将每相邻的2个有序元素序列看做一组，相邻的两组进行二路归并</p>
<p>第三趟，将每相邻的4个有序元素序列看做一组，相邻的两组进行二路归并</p>
<p>&hellip;.</p>
<p>直至所有元素都有序</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210610115158.gif" alt="图片来自CSDN@非晚非晚"  /></p>
<h3 id="2代码实现-5">2.代码实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="o">*</span><span class="n">B</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="c1">//辅助数组，长度等于A数组
</span><span class="c1"></span>
<span class="c1">//A[low...mid]和A[mid+1...high]各自有序，将两个部分归并
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">Merge</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span><span class="kt">int</span> <span class="n">mid</span><span class="p">,</span><span class="kt">int</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="c1">//将A[low...high]复制到B
</span><span class="c1"></span>        <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">low</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">k</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//归并
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="c1">//较小者复制到A中
</span><span class="c1"></span>            <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
        <span class="k">else</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
    <span class="p">}</span><span class="c1">//for
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">mid</span><span class="p">)</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">)</span> <span class="n">A</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span><span class="kt">int</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">low</span><span class="o">&lt;</span><span class="n">high</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="c1">//从中间划分
</span><span class="c1"></span>        <span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span><span class="c1">//左部分归并
</span><span class="c1"></span>        <span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">high</span><span class="p">);</span><span class="c1">//右部分归并
</span><span class="c1"></span>        <span class="n">Merge</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">high</span><span class="p">);</span><span class="c1">//两部分归并
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>关于<code>merge</code>方法可以对照下图理解</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210609083921.png" alt=""  /></p>
</blockquote>
<h2 id="基数排序">基数排序</h2>
<p><span style="border:2px dashed #e01;padding:3px 5px">基数算法不是基于“比较”的排序算法</span></p>
<h3 id="1算法思想-6">1.算法思想</h3>
<p>（具体的例子）</p>
<p>对于一个元素最高位为3位数的序列，将不足3位的元素前面补0.</p>
<p>第一趟 按“个位“<u>分配、收集</u>：得到按“个位”递减排序的序列</p>
<p>第二趟按“十位分配、收集：得到按“十位”递减排序的序列，“十位相同的按“个位递减排序</p>
<p>第三趙按“百位”分配、收集：得到一个按“百位递减排列的序列，若“百位”相同则按“十位递减排列，若“十位还相同则按“个位递减排列。</p>
<p><strong>定义如下</strong></p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210609101720.png" alt="image-20210609101712975"  /></p>
<h3 id="2效率分析">2.效率分析</h3>
<h4 id="21-空间">2.1 空间</h4>
<p>需要 r 个辅助队列，空间复杂度 = O(r)</p>
<h4 id="22-时间">2.2 时间</h4>
<p>⼀趟分配O(n)，⼀趟收集O(r)，总共 d 趟分配、收集，总的时间复杂度=$O(d(n+r))$</p>
<h4 id="23稳定性">2.3稳定性</h4>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210609103004.png" alt=""  /></p>
<h3 id="3拓展应用">3.拓展应用</h3>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210609103234.png" alt=""  /></p>
<p><span style="border-bottom:3px solid #67b440">应用方向</span></p>
<p>①数据元素的关键字可以⽅便地拆分为 d 组，且 d 较⼩</p>
<p>②每组关键字的取值范围不⼤，即 r 较⼩</p>
<p>③数据元素个数 n 较⼤</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
        
            <a href="/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">冒泡排序</a>
        
            <a href="/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/">选择排序</a>
        
            <a href="/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/">插入排序</a>
        
            <a href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">快速排序</a>
        
            <a href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">归并排序</a>
        
            <a href="/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">计数排序</a>
        
            <a href="/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/">希尔排序</a>
        
            <a href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/">堆排序</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="has-image">
    <a href="/p/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3/">
        
        
            <div class="article-image">
                
                    <img src="https://picsum.photos/seed/waibupaixu/640/360" loading="lazy" data-key="" data-hash="https://picsum.photos/seed/waibupaixu/640/360"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">外部排序相关</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/">
        
        

        <div class="article-details">
            <h2 class="article-title">查找算法相关</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/">
        
        

        <div class="article-details">
            <h2 class="article-title">图的存储</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/">
        
        

        <div class="article-details">
            <h2 class="article-title">图的应用</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/">
        
        

        <div class="article-details">
            <h2 class="article-title">图的遍历</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
     
        
    <script src='//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js'></script>
<div id="waline" class="waline-container"></div>
<style>
    .waline-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
    .waline-container .vcount {
        color: var(--card-text-color-main);
    }
</style><script>
    
    new Waline({"avatar":"robohash","dark":"html[data-scheme=\"dark\"]","el":"#waline","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/qq","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tw-emoji"],"highlight":true,"locale":{"admin":"Admin"},"placeholder":"说点什么༼ つ ◕_◕ ༽つ","requiredMeta":["name","email","url"],"serverURL":"https://waline-q3l7of5hj-fintinger.vercel.app/","visitor":true});
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2018 - 
        
        2021 Archai &#39;s blog
    </section>
    
    <section class="powerby">
        
            Archai <br/>
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.5.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>

    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

        </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#相关概念">相关概念</a>
      <ol>
        <li><a href="#1评价指标">1.评价指标</a></li>
        <li><a href="#2分类">2.分类</a></li>
      </ol>
    </li>
    <li><a href="#插入排序">插入排序</a>
      <ol>
        <li><a href="#1算法思想">1.算法思想</a></li>
        <li><a href="#2代码实现">2.代码实现</a></li>
        <li><a href="#3优化思路">3.优化思路</a></li>
      </ol>
    </li>
    <li><a href="#希尔排序">希尔排序</a>
      <ol>
        <li><a href="#1算法思想-1">1.算法思想</a></li>
        <li><a href="#2代码实现-1">2.代码实现</a></li>
      </ol>
    </li>
    <li><a href="#冒泡排序">冒泡排序</a>
      <ol>
        <li><a href="#1算法思想-2">1.算法思想</a></li>
        <li><a href="#2代码实现-2">2.代码实现</a></li>
      </ol>
    </li>
    <li><a href="#快速排序">快速排序</a>
      <ol>
        <li><a href="#1算法思想-3">1.算法思想</a></li>
        <li><a href="#2代码实现-3">2.代码实现</a></li>
        <li><a href="#3优化思路-1">3.优化思路</a></li>
        <li><a href="#4注意">4.注意</a></li>
      </ol>
    </li>
    <li><a href="#简单选择排序">简单选择排序</a>
      <ol>
        <li><a href="#1算法思想-4">1.算法思想</a></li>
        <li><a href="#2代码实现-4">2.代码实现</a></li>
      </ol>
    </li>
    <li><a href="#堆排序">堆排序☆</a>
      <ol>
        <li><a href="#1建立大根堆">1.建立大根堆</a>
          <ol>
            <li><a href="#思路">思路</a></li>
            <li><a href="#代码实现">代码实现</a></li>
          </ol>
        </li>
        <li><a href="#2大根堆排序">2.大根堆排序</a>
          <ol>
            <li><a href="#算法思想">算法思想</a></li>
            <li><a href="#代码实现-1">代码实现</a></li>
          </ol>
        </li>
        <li><a href="#3效率分析">3.效率分析</a></li>
        <li><a href="#4堆的插入与删除">4.堆的插入与删除</a>
          <ol>
            <li><a href="#41-插入">4.1 插入</a></li>
            <li><a href="#42-删除">4.2 删除</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#归并排序">归并排序</a>
      <ol>
        <li><a href="#1算法思想-5">1.算法思想</a></li>
        <li><a href="#2代码实现-5">2.代码实现</a></li>
      </ol>
    </li>
    <li><a href="#基数排序">基数排序</a>
      <ol>
        <li><a href="#1算法思想-6">1.算法思想</a></li>
        <li><a href="#2效率分析">2.效率分析</a>
          <ol>
            <li><a href="#21-空间">2.1 空间</a></li>
            <li><a href="#22-时间">2.2 时间</a></li>
            <li><a href="#23稳定性">2.3稳定性</a></li>
          </ol>
        </li>
        <li><a href="#3拓展应用">3.拓展应用</a></li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

    </div>
    <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script type="text/javascript" src="/js/clipboard/clipbordComplete.js" defer></script>
<script type="text/javascript" src="/js/loadingPage.js" defer></script>
<script type="text/javascript" src="/js/welcomePage.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>


    <div style="background:url('https://s2.hdslb.com/bfs/static/blive/blfe-dynamic-web/static/img/rocket_top.bcc748c3.png') center/cover;display: none"
         id="goTop"
         class="xl:w-60 xl:h-60 w-48 h-48 fixed  bg-gray-900 z-40 right-0 bottom-0 xl:right-10 xl:bottom-10 cursor-pointer"></div>
</div>
</body>
</html>