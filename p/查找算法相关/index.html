<!DOCTYPE html>
<html lang="zh-cn" dir=" auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>查找算法相关 | Archai&#39;s home</title>
<meta name="keywords" content="数据结构, 顺序查找, 折半查找, B树, 散列查找" />
<meta name="description" content="顺序查找 typedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int Seq_Search(SSTable ST,int key){ ST.elem[0]=key; int i; for (i = ST.TableLen;ST.elem[i]!=key ; i--) {}//从后往前查找，最终返回下标i  return i;//返回0说明没找到 } 效率分析 对于长度为n的顺序表，如果查找成功 $$ ASL={\frac{1&#43;2&#43;&hellip;&#43;n}{n}}=\frac{n&#43;1}{2} $$ 若果查找失败，则 $ASL=n&#43;1$
总体上，该算法时间复杂度为 $O(n)$
优化思路 1.如果使得表中的元素有序存放……，可以构造出一棵查找判定树
此时，查找失败时$ASL=\frac{1&#43;2&#43;&hellip;&#43;n&#43;n}{n&#43;1}=\frac{n}{2}&#43;\frac{n}{n&#43;1}$
优点： 容易查找失败时ASL更小
2.如果各元素被查找的概率不同……，可以把概率大的靠前
优点： 容易查找成功时ASL更小
折半查找  折半查找，又称“二分查找”，仅适用于有序的顺序表。
 针对升序排列的顺序表，代码实现如下
typedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int BinarySearch(SSTable L,int key){ int low=0,high=L.TableLen-1,mid; while (low&lt;=high) { mid=(low&#43;high)/2; if (L.">
<meta name="author" content="Archai">
<link rel="canonical" href="https://www.fintinger.site/p/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.7d1f24e3454b61b128688cd7c3eae16b13deed898b6ab3b54242dcf1a74fe716.css" integrity="sha256-fR8k40VLYbEoaIzXw&#43;rhaxPe7YmLarO1QkLc8adP5xY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.fintinger.site/images/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.fintinger.site/images/favicon.ico">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.fintinger.site/images/favicon.ico">
<link rel="apple-touch-icon" href="https://www.fintinger.site/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.fintinger.site/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link crossorigin="anonymous" href="/assets/css/external/external.css" rel="preload stylesheet" as="style">
<meta property="og:title" content="查找算法相关" />
<meta property="og:description" content="顺序查找 typedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int Seq_Search(SSTable ST,int key){ ST.elem[0]=key; int i; for (i = ST.TableLen;ST.elem[i]!=key ; i--) {}//从后往前查找，最终返回下标i  return i;//返回0说明没找到 } 效率分析 对于长度为n的顺序表，如果查找成功 $$ ASL={\frac{1&#43;2&#43;&hellip;&#43;n}{n}}=\frac{n&#43;1}{2} $$ 若果查找失败，则 $ASL=n&#43;1$
总体上，该算法时间复杂度为 $O(n)$
优化思路 1.如果使得表中的元素有序存放……，可以构造出一棵查找判定树
此时，查找失败时$ASL=\frac{1&#43;2&#43;&hellip;&#43;n&#43;n}{n&#43;1}=\frac{n}{2}&#43;\frac{n}{n&#43;1}$
优点： 容易查找失败时ASL更小
2.如果各元素被查找的概率不同……，可以把概率大的靠前
优点： 容易查找成功时ASL更小
折半查找  折半查找，又称“二分查找”，仅适用于有序的顺序表。
 针对升序排列的顺序表，代码实现如下
typedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int BinarySearch(SSTable L,int key){ int low=0,high=L.TableLen-1,mid; while (low&lt;=high) { mid=(low&#43;high)/2; if (L." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.fintinger.site/p/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-06T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-06-06T00:00:00&#43;00:00" /><meta property="og:site_name" content="Archai&#39;s home" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="查找算法相关"/>
<meta name="twitter:description" content="顺序查找 typedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int Seq_Search(SSTable ST,int key){ ST.elem[0]=key; int i; for (i = ST.TableLen;ST.elem[i]!=key ; i--) {}//从后往前查找，最终返回下标i  return i;//返回0说明没找到 } 效率分析 对于长度为n的顺序表，如果查找成功 $$ ASL={\frac{1&#43;2&#43;&hellip;&#43;n}{n}}=\frac{n&#43;1}{2} $$ 若果查找失败，则 $ASL=n&#43;1$
总体上，该算法时间复杂度为 $O(n)$
优化思路 1.如果使得表中的元素有序存放……，可以构造出一棵查找判定树
此时，查找失败时$ASL=\frac{1&#43;2&#43;&hellip;&#43;n&#43;n}{n&#43;1}=\frac{n}{2}&#43;\frac{n}{n&#43;1}$
优点： 容易查找失败时ASL更小
2.如果各元素被查找的概率不同……，可以把概率大的靠前
优点： 容易查找成功时ASL更小
折半查找  折半查找，又称“二分查找”，仅适用于有序的顺序表。
 针对升序排列的顺序表，代码实现如下
typedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int BinarySearch(SSTable L,int key){ int low=0,high=L.TableLen-1,mid; while (low&lt;=high) { mid=(low&#43;high)/2; if (L."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://www.fintinger.site/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "查找算法相关",
      "item": "https://www.fintinger.site/p/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "查找算法相关",
  "name": "查找算法相关",
  "description": "顺序查找 typedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int Seq_Search(SSTable ST,int key){ ST.elem[0]=key; int i; for (i = ST.TableLen;ST.elem[i]!=key ; i--) {}//从后往前查找，最终返回下标i  return i;//返回0说明没找到 } 效率分析 对于长度为n的顺序表，如果查找成功 $$ ASL={\\frac{1+2+\u0026hellip;+n}{n}}=\\frac{n+1}{2} $$ 若果查找失败，则 $ASL=n+1$\n总体上，该算法时间复杂度为 $O(n)$\n优化思路 1.如果使得表中的元素有序存放……，可以构造出一棵查找判定树\n此时，查找失败时$ASL=\\frac{1+2+\u0026hellip;+n+n}{n+1}=\\frac{n}{2}+\\frac{n}{n+1}$\n优点： 容易查找失败时ASL更小\n2.如果各元素被查找的概率不同……，可以把概率大的靠前\n优点： 容易查找成功时ASL更小\n折半查找  折半查找，又称“二分查找”，仅适用于有序的顺序表。\n 针对升序排列的顺序表，代码实现如下\ntypedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int BinarySearch(SSTable L,int key){ int low=0,high=L.TableLen-1,mid; while (low\u0026lt;=high) { mid=(low+high)/2; if (L.",
  "keywords": [
    "数据结构", "顺序查找", "折半查找", "B树", "散列查找"
  ],
  "articleBody": "顺序查找 typedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int Seq_Search(SSTable ST,int key){ ST.elem[0]=key; int i; for (i = ST.TableLen;ST.elem[i]!=key ; i--) {}//从后往前查找，最终返回下标i  return i;//返回0说明没找到 } 效率分析 对于长度为n的顺序表，如果查找成功 $$ ASL={\\frac{1+2+…+n}{n}}=\\frac{n+1}{2} $$ 若果查找失败，则 $ASL=n+1$\n总体上，该算法时间复杂度为 $O(n)$\n优化思路 1.如果使得表中的元素有序存放……，可以构造出一棵查找判定树\n此时，查找失败时$ASL=\\frac{1+2+…+n+n}{n+1}=\\frac{n}{2}+\\frac{n}{n+1}$\n优点： 容易查找失败时ASL更小\n2.如果各元素被查找的概率不同……，可以把概率大的靠前\n优点： 容易查找成功时ASL更小\n折半查找  折半查找，又称“二分查找”，仅适用于有序的顺序表。\n 针对升序排列的顺序表，代码实现如下\ntypedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int BinarySearch(SSTable L,int key){ int low=0,high=L.TableLen-1,mid; while (lowhigh) { mid=(low+high)/2; if (L.elem[mid]==key) return key; else if(L.elem[mid]key)//从前半部分继续查找  high=mid-1; else//从后半部分继续查找  low=mid+1; } return -1; } 折半查找判定树 对于一个给定的有序顺序表，\n若其中元素个数为奇数个，则折半后构造出的判定树满足数量关系“左子树=右子树”；\n若元素个数为偶数个，则根据$mid=\\left \\lfloor \\frac{low+high}{2} \\right \\rfloor$,即mid向下取整，此时有”左子树=右子树-1“\n故，不考虑失败结点，折半查找二叉树中满足 右子树结点数-左子树结点数=0或1，因此对于编号为1~16的元素，不考虑失败结点，构造其折半查找判定树应该为：\n特征：\n① 折半查找判定树一定是平衡二叉树(AVL)；\n②判定树结点的关键字满足 左③ 失败结点有n+1个（等于成功结点的空链域数量）\n效率分析 由于折半查找判定树的树高不超过$\\left \\lceil \\log_2(n+1) \\right \\rceil$，因此\n查找失败|成功的情况下，$ASL \\leq n$\n其时间复杂度为$O(\\log_2n)$\n分块查找  分块查找最大的特征就是“块内无序，块间有序”。\n //定义分块的索引表 typedef struct{ int maxValue;//块中最大值  int low,high;//块在顺序表中的起始和结束地址 }Index; //顺序表存储实际元素 int List[100]; 算法思想 对于给定的一串元素，整体上可能是无序的，但是如果按照最大有序序列划分之后，各块内就变得有序了。这样我们就可以根据分好的块建立的索引来快速定位key所在的区间。\n分块查找，又称索引顺序查找，算法过程如下：\n①在索引表中确定待查记录所属的分块（可顺序、可折半）\n💥注意在索引表中折半查找时，如果key没有直接等于maxValue，那么根据二分查找算法，当lowhigh时，需要在low指向的块内继续进行查找\n②在块内顺序查找\n查找效率分析 只考虑特殊情况，假设长度为n的表被均匀地分成b块，每块s个元素，那么：\n设索引表和块内的平均查找长度分别为$L_I,L_S$，则整个查找过程的平均查找长度 $$ ASL=L_I+L_S $$ 具体地，如果对索引表采用顺序查找的方式：\n$L_I={\\frac{1+2+…+b}{b}}=\\frac{b+1}{2}$\n$L_S={\\frac{1+2+…+s}{s}}=\\frac{s+1}{2}$\n则$ASL=\\frac{s^2+2s+n}{2s}$，当$s=\\sqrt{n}$ 时，$ASL_{min}=\\sqrt{n}+1$\n如果采用折半查找的方式：\n$ASL=\\left \\lceil \\log_2(b+1) \\right \\rceil+\\frac{s+1}{2}$\n优化思路 如果插入某个元素，顺序表方式复杂度太高，故可采用链式存储的方式存储数据元素。\nB树  B树，又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。\n 对于一个m阶B树其核心特征如下：\n\nB树高度  对于B树的高度，一般不包括叶结点（失败的结点）\n 最小高度 为使得有n个关键字的m阶B树有最小高度，那么每个结点应该尽可能地满，有m-1个关键字，m个分叉，则有\n$n\\leq(m-1)(1+m+m^2+…+m^{h-1})=m^h-1$ 可以得到，$h\\geq \\log_m(n+1)$\n最大高度 方式一：\n\n方式二：\n\n插入删除操作 核心要求： ①对m阶B树除根节点外，结点关键字个数 m/2 -1 ≤ n ≤ m-1\r②子树0插入操作 新元素一定是插入到最底层“终端节点”，用“查找”来确定插入位置\n在插入key后，若导致原结点关键字数超过上限，则从中间位置（m/2上取整）将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（m/2）的结点插入原结点的父结点。\n若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1。\n下图分别演示两种关键字超出结点上限的情况\n\n\n删除操作 \nB+树  有类似分块查找，上层保存下层结点中的最大值，但又保存了B树的一些特性\n \n一棵m阶B+树满足以下条件：\n\n查找 B+树中，无论查找成功与否，最终一定要走到最下面一层结点。\n可以从根节点出发逐层查找，也可以借助指针p进行顺序查找\n对比B树 \n散列查找  散列表(Hash Table)，又称哈希表。是一种数据结构，特点是：数据元素的关键字与其存储地址直接相关。\n 相关概念 同义词： 若不同的关键字通过散列函数映射到同一个值，则称它们为“同义词”\n冲突： 通过散列函数确定的位置已经存放了其他元素，则称这种情况为“冲突”\n哈希函数： 关键字与存放地址之间的转换函数。\n**查找长度： **在查找运算中，需要对比关键字的次数称为查找长度。可能为0。\n**装填因子：**对一个有n个关键字形成的长度为l的散列表，其装填因子 $\\alpha=\\frac{n}{l}$，表示的是查找失败时的平均查找长度ASL（当查找长度可为0的时）。装填因子越大说明散列表越满。\n处理冲突的方法 1.拉链法(链接法或链地址法) \n2.开放定址法 所谓开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表开放。其数学递推公式为：\n\n其中，i=0,1,2,…,k(k ≤ m-1)，m表示散列表长；$d_i$为增量序列；i可理解为“第i次发生冲突”\n对于增量序列$d_i$，有三种方法确定：①线性探测法；②平方探测法；③伪随机序列法\n①线性探测法 $d_i$=0,1,2,3，… ，m-1；即发生冲突时，每次往后探测相邻的下一个单元是否为空\n例如，有一堆数据元素，关键字分别为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数H（key）=key%13，\n在存放1时，由于 1%13=1，但位置1处已经存在14，因此会后移一位存放到$H_1$=(1+$d_1$)%16=2的位置:\n\n查找\n对于一个给定的key，通过开放定址法给出的递推公式确定其位置，若冲突，则寻找下一个位置，直至找到或遇到空地址失败为止。值得注意的是，在计算平均查找长度时，空位置的比较也记作一次，此外如果能够越早遇到空位置，就能越早确定查找失败。\n删除\n删除操作不能简单地将某位置置为空（若置为空，将截断在它之后填⼊ 散列表的同义词结点的查找路径，可能导致查找操作误判），而应该做⼀个“删除标记”，进⾏逻辑删除。\n平均查找长度\n对于下图中的散列表{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数H（key）=key%13\n\n成功：\n\n失败：\n\n如果通过递推式映射到0的位置，只需1次对比\n如果是1的位置，需要1,2,3…13，总共13次对比\n如果是2的位置，需要2,3，… 13，总共12次对比\n……\n线性探测法很容易造成同义词、⾮同义词的“聚集（堆积）”现象，严重影响查找效率\n②平方探测法 $d_i=0^2,1^2，-1^2,2^2，-2^2…k^2,-k^2$；称为平方探测法，又称二次探测法，其中k≤m/2.\n注意： 散列表⻓度m必须是⼀个可以表示成4j + 3的素数，才能探测到所有位置——《数论》\n\n如图，可见，当表长为8时，没有探测到整个表。\n③伪随机序列法 di 是⼀个伪随机序列，如 di= 0, 5, 24, 11, …\n3.再散列法(再哈希) 除了原始的散列函数 H(key) 之外，多准备⼏个散列函数， 当散列函数冲突时，⽤下⼀个散列函数计算⼀个新地址，直到不冲突为⽌。\n常见的散列函数  目标：让不同关键字的冲突尽可能地少\n 1.除留余数法 H(key)= key % p\n散列表表长为m，取一个不大于m但最接近或等于m的质数p，分布更均匀，冲突更少。参见《数论》\n2. 直接定址法 H(key) = key 或 H(key) = a × key + b\n其中，a和b是常数。这种方法计算最简单且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。\n例如：学生学号的保存\n3.数字分析法 选取数码分布较为均匀的若干位作为散列地址\n设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时可选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。\n例如：对手机号码，可以设计后四位作为散列地址\n4.平方取中法 取关键字的平方值的中间几位作为散列地址。\n具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。\n例：要存储整个学校的学生信息，以“身份证号”作为关键字设计散列函数\n 散列查找是“空间换时间”的算法，在散列表设计合理的情况下，散列表越长，冲突概率越低。\n ",
  "wordCount" : "271",
  "inLanguage": "zh-cn",
  "datePublished": "2021-06-06T00:00:00Z",
  "dateModified": "2021-06-06T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Archai"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.fintinger.site/p/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Archai's home",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.fintinger.site/images/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id=" top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script>
        document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>

<header class="header animate__animated animate__bounce animate__slideInDown animate__fast">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.fintinger.site" accesskey="h" title="🛖Home (Alt + H)">🛖Home</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.fintinger.site/posts/" title="Posts📑">
                    <span>Posts📑</span>
                </a>
            </li>
            <li>
                <a href="https://www.fintinger.site/categories/" title="Categories🛒">
                    <span>Categories🛒</span>
                </a>
            </li>
            <li>
                <a href="https://www.fintinger.site/search/" title="Search🔎 (Alt &#43; /)" accesskey=/>
                    <span>Search🔎</span>
                </a>
            </li>
            <li>
                <a href="https://www.fintinger.site/archives/" title="Timeline🕰️">
                    <span>Timeline🕰️</span>
                </a>
            </li>
            <li>
                <a href="https://www.fintinger.site/about/" title="About🥳">
                    <span>About🥳</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single  animate__animated animate__bounce animate__fadeIn">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://www.fintinger.site">Home</a>&nbsp;»&nbsp;<a href="https://www.fintinger.site/posts/">Posts</a></div>
    <h1 class="post-title">
      查找算法相关
    </h1>
    <div class="post-meta"><span title='2021-06-06 00:00:00 +0000 UTC'>Jun 6, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Archai

</div>
  </header> <div class="toc  animate__animated">
    <details >
        <summary accesskey="c" title="(Alt + C)" style="height: 30px">
            <span class="details">Table of Contents</span>
            <span id="pinToc" class="fab fa-thumb-tack" title="pinned/unpinned"></span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e9%a1%ba%e5%ba%8f%e6%9f%a5%e6%89%be" aria-label="顺序查找">顺序查找</a><ul>
                        
                <li>
                    <a href="#%e6%95%88%e7%8e%87%e5%88%86%e6%9e%90" aria-label="效率分析">效率分析</a></li>
                <li>
                    <a href="#%e4%bc%98%e5%8c%96%e6%80%9d%e8%b7%af" aria-label="优化思路">优化思路</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8a%98%e5%8d%8a%e6%9f%a5%e6%89%be" aria-label="折半查找">折半查找</a><ul>
                        
                <li>
                    <a href="#%e6%8a%98%e5%8d%8a%e6%9f%a5%e6%89%be%e5%88%a4%e5%ae%9a%e6%a0%91" aria-label="折半查找判定树">折半查找判定树</a></li>
                <li>
                    <a href="#%e6%95%88%e7%8e%87%e5%88%86%e6%9e%90-1" aria-label="效率分析">效率分析</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%86%e5%9d%97%e6%9f%a5%e6%89%be" aria-label="分块查找">分块查找</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3" aria-label="算法思想">算法思想</a></li>
                <li>
                    <a href="#%e6%9f%a5%e6%89%be%e6%95%88%e7%8e%87%e5%88%86%e6%9e%90" aria-label="查找效率分析">查找效率分析</a></li>
                <li>
                    <a href="#%e4%bc%98%e5%8c%96%e6%80%9d%e8%b7%af-1" aria-label="优化思路">优化思路</a></li></ul>
                </li>
                <li>
                    <a href="#b%e6%a0%91" aria-label="B树">B树</a><ul>
                        
                <li>
                    <a href="#b%e6%a0%91%e9%ab%98%e5%ba%a6" aria-label="B树高度">B树高度</a><ul>
                        
                <li>
                    <a href="#%e6%9c%80%e5%b0%8f%e9%ab%98%e5%ba%a6" aria-label="最小高度">最小高度</a></li>
                <li>
                    <a href="#%e6%9c%80%e5%a4%a7%e9%ab%98%e5%ba%a6" aria-label="最大高度">最大高度</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8f%92%e5%85%a5%e5%88%a0%e9%99%a4%e6%93%8d%e4%bd%9c" aria-label="插入删除操作">插入删除操作</a><ul>
                        
                <li>
                    <a href="#%e6%8f%92%e5%85%a5%e6%93%8d%e4%bd%9c" aria-label="插入操作">插入操作</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e6%93%8d%e4%bd%9c" aria-label="删除操作">删除操作</a></li></ul>
                </li>
                <li>
                    <a href="#b%e6%a0%91-1" aria-label="B&#43;树">B+树</a><ul>
                        
                <li>
                    <a href="#%e6%9f%a5%e6%89%be" aria-label="查找">查找</a></li>
                <li>
                    <a href="#%e5%af%b9%e6%af%94b%e6%a0%91" aria-label="对比B树">对比B树</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%95%a3%e5%88%97%e6%9f%a5%e6%89%be" aria-label="散列查找">散列查找</a><ul>
                        
                <li>
                    <a href="#%e7%9b%b8%e5%85%b3%e6%a6%82%e5%bf%b5" aria-label="相关概念">相关概念</a></li>
                <li>
                    <a href="#%e5%a4%84%e7%90%86%e5%86%b2%e7%aa%81%e7%9a%84%e6%96%b9%e6%b3%95" aria-label="处理冲突的方法">处理冲突的方法</a><ul>
                        
                <li>
                    <a href="#1%e6%8b%89%e9%93%be%e6%b3%95%e9%93%be%e6%8e%a5%e6%b3%95%e6%88%96%e9%93%be%e5%9c%b0%e5%9d%80%e6%b3%95" aria-label="1.拉链法(链接法或链地址法)">1.拉链法(链接法或链地址法)</a></li>
                <li>
                    <a href="#2%e5%bc%80%e6%94%be%e5%ae%9a%e5%9d%80%e6%b3%95" aria-label="2.开放定址法">2.开放定址法</a><ul>
                        
                <li>
                    <a href="#%e7%ba%bf%e6%80%a7%e6%8e%a2%e6%b5%8b%e6%b3%95" aria-label="①线性探测法">①线性探测法</a></li>
                <li>
                    <a href="#%e5%b9%b3%e6%96%b9%e6%8e%a2%e6%b5%8b%e6%b3%95" aria-label="②平方探测法">②平方探测法</a></li>
                <li>
                    <a href="#%e4%bc%aa%e9%9a%8f%e6%9c%ba%e5%ba%8f%e5%88%97%e6%b3%95" aria-label="③伪随机序列法">③伪随机序列法</a></li></ul>
                </li>
                <li>
                    <a href="#3%e5%86%8d%e6%95%a3%e5%88%97%e6%b3%95%e5%86%8d%e5%93%88%e5%b8%8c" aria-label="3.再散列法(再哈希)">3.再散列法(再哈希)</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e7%9a%84%e6%95%a3%e5%88%97%e5%87%bd%e6%95%b0" aria-label="常见的散列函数">常见的散列函数</a><ul>
                        
                <li>
                    <a href="#1%e9%99%a4%e7%95%99%e4%bd%99%e6%95%b0%e6%b3%95" aria-label="1.除留余数法">1.除留余数法</a></li>
                <li>
                    <a href="#2--%e7%9b%b4%e6%8e%a5%e5%ae%9a%e5%9d%80%e6%b3%95" aria-label="2.  直接定址法">2.  直接定址法</a></li>
                <li>
                    <a href="#3%e6%95%b0%e5%ad%97%e5%88%86%e6%9e%90%e6%b3%95" aria-label="3.数字分析法">3.数字分析法</a></li>
                <li>
                    <a href="#4%e5%b9%b3%e6%96%b9%e5%8f%96%e4%b8%ad%e6%b3%95" aria-label="4.平方取中法">4.平方取中法</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>
  <div class="post-content"><h2 id="顺序查找">顺序查找<a hidden class="anchor" aria-hidden="true" href="#顺序查找">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{<span style="color:#75715e">//查找表的数据结构（顺序表）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>elem;<span style="color:#75715e">//动态数组基址
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> TableLen;<span style="color:#75715e">//查找表长度
</span><span style="color:#75715e"></span>}SSTable;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Seq_Search</span>(SSTable ST,<span style="color:#66d9ef">int</span> key){
    ST.elem[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span>key;
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> ST.TableLen;ST.elem[i]<span style="color:#f92672">!=</span>key ; i<span style="color:#f92672">--</span>) {}<span style="color:#75715e">//从后往前查找，最终返回下标i
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> i;<span style="color:#75715e">//返回0说明没找到
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="效率分析">效率分析<a hidden class="anchor" aria-hidden="true" href="#效率分析">#</a></h3>
<p>对于长度为n的顺序表，如果<u>查找成功</u>
$$
ASL={\frac{1+2+&hellip;+n}{n}}=\frac{n+1}{2}
$$
若果查找失败，则 $ASL=n+1$</p>
<p>总体上，该算法时间复杂度为 $O(n)$</p>
<h3 id="优化思路">优化思路<a hidden class="anchor" aria-hidden="true" href="#优化思路">#</a></h3>
<p>1.<span style="background-color:#fff006">如果使得表中的元素有序存放……</span>，可以构造出一棵查找判定树</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210602101845.png" style="zoom:33%;" /></p>
<p>此时，查找失败时$ASL=\frac{1+2+&hellip;+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}$</p>
<p><strong>优点：</strong> <span style="color:#e01">容易查找失败时ASL更小</span></p>
<p>2.<span style="background-color:#fff006">如果各元素被查找的概率不同……</span>，可以把概率大的靠前</p>
<p><strong>优点：</strong> <span style="color:#e01">容易查找成功时ASL更小</span></p>
<h2 id="折半查找">折半查找<a hidden class="anchor" aria-hidden="true" href="#折半查找">#</a></h2>
<blockquote>
<p>折半查找，又称“二分查找”，仅适用于<strong>有序的顺序表</strong>。</p>
</blockquote>
<p><span style="color:#e01">针对升序排列的顺序表</span>，代码实现如下</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{<span style="color:#75715e">//查找表的数据结构（顺序表）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>elem;<span style="color:#75715e">//动态数组基址
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> TableLen;<span style="color:#75715e">//查找表长度
</span><span style="color:#75715e"></span>}SSTable;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BinarySearch</span>(SSTable L,<span style="color:#66d9ef">int</span> key){
    <span style="color:#66d9ef">int</span> low<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,high<span style="color:#f92672">=</span>L.TableLen<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,mid;
    <span style="color:#66d9ef">while</span> (low<span style="color:#f92672">&lt;=</span>high) {
        mid<span style="color:#f92672">=</span>(low<span style="color:#f92672">+</span>high)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">if</span> (L.elem[mid]<span style="color:#f92672">==</span>key)
            <span style="color:#66d9ef">return</span> key;
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(L.elem[mid]<span style="color:#f92672">&gt;</span>key)<span style="color:#75715e">//从前半部分继续查找
</span><span style="color:#75715e"></span>            high<span style="color:#f92672">=</span>mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">else</span><span style="color:#75715e">//从后半部分继续查找
</span><span style="color:#75715e"></span>            low<span style="color:#f92672">=</span>mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}
</code></pre></div><h3 id="折半查找判定树">折半查找判定树<a hidden class="anchor" aria-hidden="true" href="#折半查找判定树">#</a></h3>
<p>对于一个给定的有序顺序表，</p>
<p>若其中元素个数为奇数个，则折半后构造出的判定树满足数量关系“左子树=右子树”；</p>
<p>若元素个数为偶数个，则根据$mid=\left \lfloor \frac{low+high}{2} \right \rfloor$,即<span style="color:#e01;">mid向下取整</span>，此时有”左子树=右子树-1“</p>
<p>故，不考虑失败结点，折半查找二叉树中满足 <span style="background-color:#fff006;">右子树结点数-左子树结点数=0或1</span>，因此对于<strong>编号</strong>为1~16的元素，不考虑失败结点，构造其折半查找判定树应该为：</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210602111935.png" style="zoom:30%;" /></p>
<p><strong>特征：</strong></p>
<p>① 折半查找判定树一定是平衡二叉树(AVL)；</p>
<p>②判定树结点的关键字满足 左&lt;中&lt;右，因此满足二叉排序树(BST)；</p>
<p>③ 失败结点有n+1个（等于成功结点的空链域数量）</p>
<h3 id="效率分析-1">效率分析<a hidden class="anchor" aria-hidden="true" href="#效率分析-1">#</a></h3>
<p>由于折半查找判定树的树高不超过$\left \lceil \log_2(n+1) \right \rceil$，因此</p>
<p>查找失败|成功的情况下，$ASL \leq n$</p>
<p>其时间复杂度为$O(\log_2n)$</p>
<h2 id="分块查找">分块查找<a hidden class="anchor" aria-hidden="true" href="#分块查找">#</a></h2>
<blockquote>
<p>分块查找最大的特征就是“块内无序，块间有序”。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">//定义分块的索引表
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
    <span style="color:#66d9ef">int</span> maxValue;<span style="color:#75715e">//块中最大值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> low,high;<span style="color:#75715e">//块在顺序表中的起始和结束地址
</span><span style="color:#75715e"></span>}Index;
<span style="color:#75715e">//顺序表存储实际元素
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> List[<span style="color:#ae81ff">100</span>];
</code></pre></div><h3 id="算法思想">算法思想<a hidden class="anchor" aria-hidden="true" href="#算法思想">#</a></h3>
<p>对于给定的一串元素，整体上可能是无序的，但是如果按照最大有序序列划分之后，各块内就变得有序了。这样我们就可以根据分好的块建立的索引来快速定位key所在的区间。</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210603104602.png" style="zoom:50%;" /></p>
<p>分块查找，又称索引顺序查找，算法过程如下：</p>
<p>①在索引表中确定待查记录所属的分块（可顺序、可折半）</p>
<p>💥<span style="background-color:#fff006">注意在索引表中折半查找时，如果key没有直接等于maxValue，那么根据二分查找算法，当low&gt;high时，需要在low指向的块内继续进行查找</span></p>
<p>②在块内顺序查找</p>
<h3 id="查找效率分析">查找效率分析<a hidden class="anchor" aria-hidden="true" href="#查找效率分析">#</a></h3>
<p>只考虑特殊情况，假设<span style="color:#e01">长度为n的表被均匀地分成b块，每块s个元素</span>&gt;，那么：</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210603110155.png" style="zoom: 80%;" /></p>
<p>设索引表和块内的平均查找长度分别为$L_I,L_S$，则整个查找过程的平均查找长度
$$
ASL=L_I+L_S
$$
具体地，如果<u>对索引表</u>采用<span style="background:#fff006">顺序查找</span>的方式：</p>
<p>$L_I={\frac{1+2+&hellip;+b}{b}}=\frac{b+1}{2}$</p>
<p>$L_S={\frac{1+2+&hellip;+s}{s}}=\frac{s+1}{2}$</p>
<p>则$ASL=\frac{s^2+2s+n}{2s}$，当$s=\sqrt{n}$ 时，$ASL_{min}=\sqrt{n}+1$</p>
<p>如果采用<span style="background:#fff006">折半查找</span>的方式：</p>
<p>$ASL=\left \lceil \log_2(b+1) \right \rceil+\frac{s+1}{2}$</p>
<h3 id="优化思路-1">优化思路<a hidden class="anchor" aria-hidden="true" href="#优化思路-1">#</a></h3>
<p>如果插入某个元素，顺序表方式复杂度太高，故可采用链式存储的方式存储数据元素。</p>
<h2 id="b树">B树<a hidden class="anchor" aria-hidden="true" href="#b树">#</a></h2>
<blockquote>
<p>B树，又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。</p>
</blockquote>
<p>对于一个<span style="color:#e01">m阶B树</span>其核心特征如下：</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210603115805.png" alt=""  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<h3 id="b树高度">B树高度<a hidden class="anchor" aria-hidden="true" href="#b树高度">#</a></h3>
<blockquote>
<p>对于B树的高度，一般<span style="color:#e01;">不包括叶结点（失败的结点）</span></p>
</blockquote>
<h4 id="最小高度">最小高度<a hidden class="anchor" aria-hidden="true" href="#最小高度">#</a></h4>
<p>为使得<u>有n个关键字的m阶B树</u>有最小高度，那么<u>每个结点应该尽可能地满</u>，有m-1个关键字，m个分叉，则有</p>
<p>$n\leq(m-1)(1+m+m^2+&hellip;+m^{h-1})=m^h-1$  可以得到，<span style="border:3px dashed #e01;padding:3px;">$h\geq \log_m(n+1)$</span></p>
<h4 id="最大高度">最大高度<a hidden class="anchor" aria-hidden="true" href="#最大高度">#</a></h4>
<p>方式一：</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210603115918.png" alt=""  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<p>方式二：</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210603115945.png" alt=""  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<h3 id="插入删除操作">插入删除操作<a hidden class="anchor" aria-hidden="true" href="#插入删除操作">#</a></h3>
<p style="border:3px dashed #e01;padding:2px;display:table;padding:5px 10px;">核心要求：</br>    ①对m阶B树除根节点外，结点关键字个数 m/2 -1 ≤ n ≤ m-1</n></br>
②子树0<关键字1<子树1<关键字2<子树2<...</p>
<h4 id="插入操作">插入操作<a hidden class="anchor" aria-hidden="true" href="#插入操作">#</a></h4>
<p>新元素一定是插入到最底层“终端节点”，用“查找”来确定插入位置</p>
<p>在插入key后，若导致<strong>原结点关键字数超过上限</strong>，则从<strong>中间位置（m/2上取整）<strong>将其中的关键字</strong>分为两部分</strong>，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（m/2）的结点插入原结点的父结点。</p>
<p>若此时导致<strong>其父结点的关键字个数也超过了上限</strong>，则<strong>继续</strong>进行这种分裂操作，直至这个过程传到根结点为止，进而导致<strong>B树高度增1</strong>。</p>
<p>下图分别演示两种关键字超出结点上限的情况</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605154812.gif" alt="普通结点溢出"  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605154837.gif" alt="根节点溢出"  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<h4 id="删除操作">删除操作<a hidden class="anchor" aria-hidden="true" href="#删除操作">#</a></h4>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605155708.png" alt=""  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<h3 id="b树-1">B+树<a hidden class="anchor" aria-hidden="true" href="#b树-1">#</a></h3>
<blockquote>
<p>有类似分块查找，上层保存下层结点中的最大值，但又保存了B树的一些特性</p>
</blockquote>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605160212.png" alt=""  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<p>一棵<span style="color:#e01">m阶B+树</span>满足以下条件：</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605160450.png" alt=""  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<h4 id="查找">查找<a hidden class="anchor" aria-hidden="true" href="#查找">#</a></h4>
<p><span style="color:#e01">B+树中，无论查找成功与否，最终一定要走到最下面一层结点。</span></p>
<p>可以从根节点出发逐层查找，也可以借助指针p进行顺序查找</p>
<h4 id="对比b树">对比B树<a hidden class="anchor" aria-hidden="true" href="#对比b树">#</a></h4>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605161703.png" alt=""  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<h2 id="散列查找">散列查找<a hidden class="anchor" aria-hidden="true" href="#散列查找">#</a></h2>
<blockquote>
<p>散列表(Hash Table)，又称哈希表。是一种数据结构，特点是：数据元素的关键字与其存储地址直接相关。</p>
</blockquote>
<h3 id="相关概念">相关概念<a hidden class="anchor" aria-hidden="true" href="#相关概念">#</a></h3>
<p><strong>同义词：</strong> 若不同的关键字通过散列函数映射到同一个值，则称它们为“同义词”</p>
<p><strong>冲突：</strong> 通过散列函数确定的位置已经存放了其他元素，则称这种情况为“冲突”</p>
<p><strong>哈希函数：</strong> 关键字与存放地址之间的转换函数。</p>
<p>**查找长度： **在查找运算中，需要对比关键字的次数称为查找长度。可能为0。</p>
<p>**装填因子：**对一个有n个关键字形成的长度为l的散列表，其装填因子 $\alpha=\frac{n}{l}$，表示的是查找失败时的平均查找长度ASL（当查找长度可为0的时）。装填因子越大说明散列表越满。</p>
<h3 id="处理冲突的方法">处理冲突的方法<a hidden class="anchor" aria-hidden="true" href="#处理冲突的方法">#</a></h3>
<h4 id="1拉链法链接法或链地址法">1.拉链法(链接法或链地址法)<a hidden class="anchor" aria-hidden="true" href="#1拉链法链接法或链地址法">#</a></h4>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605170355.png" alt=""  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<h4 id="2开放定址法">2.开放定址法<a hidden class="anchor" aria-hidden="true" href="#2开放定址法">#</a></h4>
<p>所谓开放定址法，是指可存放新表项的空闲地址既向它的<strong>同义词表项开放</strong>，又向它的<strong>非同义词表开放</strong>。其数学递推公式为：</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605171135.png" alt=""  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<p>其中，<em>i=0,1,2,&hellip;,k(k ≤ m-1)</em>，m表示<span style="color:#e01">散列表长</span>；$d_i$为<span style="color:#e01">增量序列</span>；i可理解为“第i次发生冲突”</p>
<p>对于增量序列$d_i$，有三种方法确定：①线性探测法；②平方探测法；③伪随机序列法</p>
<h5 id="线性探测法">①线性探测法<a hidden class="anchor" aria-hidden="true" href="#线性探测法">#</a></h5>
<p><span style="background:#dedede;padding:5px">$d_i$=0,1,2,3，&hellip;  ，m-1；即发生冲突时，每次往后探测相邻的<u>下一个单元是否为空</u></span></p>
<p>例如，有一堆数据元素，关键字分别为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数H（key）=key%13，</p>
<p>在存放1时，由于 1%13=1，但位置1处已经存在14，因此会后移一位存放到$H_1$=(1+$d_1$)%16=2的位置:</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605173556.png" alt=""  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<p><strong>查找</strong></p>
<p>对于一个给定的key，通过开放定址法给出的递推公式确定其位置，若冲突，则寻找下一个位置，直至找到或遇到空地址失败为止。值得注意的是，在计算平均查找长度时，<u>空位置的比较也记作一次</u>，此外<span style="background:#fff006">如果能够越早遇到空位置，就能越早确定查找失败。</span></p>
<p><strong>删除</strong></p>
<p>删除操作不能简单地将某位置置为空（若置为空，将截断在它之后填⼊ 散列表的同义词结点的查找路径，可能导致查找操作误判），而应该<span style="background:#fff006">做⼀个“删除标记”，进⾏逻辑删除</span>。</p>
<p><strong>平均查找长度</strong></p>
<p>对于下图中的散列表{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数H（key）=key%13</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210606154801.png" alt=""  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<p>成功：</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210606154803.png" alt=""  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<p>失败：</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210606154809.png" alt=""  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<p>如果通过递推式映射到0的位置，只需1次对比</p>
<p>如果是1的位置，需要1,2,3&hellip;13，总共13次对比</p>
<p>如果是2的位置，需要2,3，&hellip; 13，总共12次对比</p>
<p>&hellip;&hellip;</p>
<p><span style="padding:5px;border:2px dashed #e01">线性探测法很容易造成同义词、⾮同义词的“聚集（堆积）”现象，严重影响查找效率</span></p>
<h5 id="平方探测法">②平方探测法<a hidden class="anchor" aria-hidden="true" href="#平方探测法">#</a></h5>
<p><span style="background:#dedede;padding:5px">$d_i=0^2,1^2，-1^2,2^2，-2^2&hellip;k^2,-k^2$；称为平方探测法，又称二次探测法，其中k≤m/2.</span></p>
<p><strong>注意：</strong> 散列表⻓度m必须是⼀个可以表示成4j + 3的素数，才能探测到所有位置&mdash;&mdash;《数论》</p>
<p><img loading="lazy" src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210606154815.png" alt=""  />
<div class="imgAlt" style="text-align: center;color: #999;font-style: italic;margin-top: -10px"></div></p>
<p>如图，可见，当表长为8时，没有探测到整个表。</p>
<h5 id="伪随机序列法">③伪随机序列法<a hidden class="anchor" aria-hidden="true" href="#伪随机序列法">#</a></h5>
<p><span style="background:#dedede;padding:5px">di 是⼀个伪随机序列，如 di= 0, 5, 24, 11, …</span></p>
<h4 id="3再散列法再哈希">3.再散列法(再哈希)<a hidden class="anchor" aria-hidden="true" href="#3再散列法再哈希">#</a></h4>
<p>除了原始的散列函数 H(key) 之外，多准备⼏个散列函数， 当散列函数冲突时，⽤下⼀个散列函数计算⼀个新地址，直到不冲突为⽌。</p>
<h3 id="常见的散列函数">常见的散列函数<a hidden class="anchor" aria-hidden="true" href="#常见的散列函数">#</a></h3>
<blockquote>
<p>目标：<u>让不同关键字的冲突尽可能地少</u></p>
</blockquote>
<h4 id="1除留余数法">1.除留余数法<a hidden class="anchor" aria-hidden="true" href="#1除留余数法">#</a></h4>
<p><em>H(key)= key % p</em></p>
<p>散列表表长为m，取一个<strong>不大于m但最接近或等于m的质数p</strong>，分布更均匀，冲突更少。参见《数论》</p>
<h4 id="2--直接定址法">2.  直接定址法<a hidden class="anchor" aria-hidden="true" href="#2--直接定址法">#</a></h4>
<p><em>H(key) = key 或 H(key) = a × key + b</em></p>
<p>其中，a和b是常数。这种方法计算最简单且不会产生冲突。它适合<strong>关键字的分布基本连续的情况</strong>，若关键字分布不连续，空位较多，则会造成存储空间的浪费。</p>
<p>例如：学生学号的保存</p>
<h4 id="3数字分析法">3.数字分析法<a hidden class="anchor" aria-hidden="true" href="#3数字分析法">#</a></h4>
<p><em>选取数码分布较为均匀的若干位作为散列地址</em></p>
<p>设关键字是r进制数（如十进制数），而<strong>r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些</strong>，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时可选取数码分布较为均匀的若干位作为散列地址。这种方法<strong>适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数</strong>。</p>
<p>例如：对手机号码，可以设计后四位作为散列地址</p>
<h4 id="4平方取中法">4.平方取中法<a hidden class="anchor" aria-hidden="true" href="#4平方取中法">#</a></h4>
<p><em>取关键字的平方值的中间几位作为散列地址。</em></p>
<p>具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于<strong>关键字的每位取值都不够均匀或均小于散列地址所需的位数。</strong></p>
<p>例：要存储整个学校的学生信息，以“身份证号”作为关键字设计散列函数</p>
<blockquote>
<p>散列查找是“空间换时间”的算法，在散列表设计合理的情况下，散列表越长，冲突概率越低。</p>
</blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://www.fintinger.site/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li>
      <li><a href="https://www.fintinger.site/tags/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/">顺序查找</a></li>
      <li><a href="https://www.fintinger.site/tags/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/">折半查找</a></li>
      <li><a href="https://www.fintinger.site/tags/b%E6%A0%91/">B树</a></li>
      <li><a href="https://www.fintinger.site/tags/%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE/">散列查找</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://www.fintinger.site/p/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/">
    <span class="title">« </span>
    <br>
    <span>排序算法相关</span>
  </a>
  <a class="next" href="https://www.fintinger.site/p/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/">
    <span class="title"> »</span>
    <br>
    <span>图的应用</span>
  </a>
</nav>

  </footer><script src='https://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js'></script>
<div id="veditor"></div>
<script>
    new Valine({
        el: '#veditor',
        appId: '6lUYMvIcPEdh8TJIHPL1V8sd-gzGzoHsz',
        appKey: 'eQh9fRmGTn757NYWg7NfDETV',
        master: '8c3025ceb5de0e61fe808054b49c325a',   
        tagMeta: ["博主","小伙伴","访客"],     
        friends:  ["7d8fe1d694bf4369865cab91848fe390","3a1c312d1834ecdcb338e5cdbae3f1f7","5ce4f387d0aa4e0054cec9c03d50805d"],  
        
        placeholder: `可以在上方填写相关信息，支持Markdown语法`,
        avatar: 'wavatar',
        enableQQ: true,
        pageSize:5,
    })
</script>
</article>
</main>

<footer class="footer">
    <span>&copy; 2022 <a href="https://www.fintinger.site">Archai&#39;s home</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>
<script src="/assets/js/extended/extend.a3aaaf62a93652db784b55fca43641ff71c19211a1e0859278db470c67f9e510.min.js"></script>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                if (id === "top") {
                document.body.scrollIntoView({
                    behavior: "smooth"
                })
                return true;
            }
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                document.body.scrollIntoView({
                    behavior: "smooth"
                })
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });
window.onerror=function(){return true;}
</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<video id="liveBgBox" autoplay loop muted poster="https://picgo-jqf.oss-cn-beijing.aliyuncs.com/img/202204091914289.png" style="display: none;"></video>
</body>
</html>