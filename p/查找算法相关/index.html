<!DOCTYPE html>
<html lang="en">
  <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='顺序查找 typedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int Seq_Search(SSTable ST,int key){ ST.elem[0]=key; int i; for (i = ST.TableLen;ST.elem[i]!=key ; i--) {}//从后往前查找，最终返回下标i  return i;//返回0说明没找到 } 效率分析 对于长度为n的顺序表，如果查找成功 $$ ASL={\frac{1&#43;2&#43;&amp;hellip;&#43;n}{n}}=\frac{n&#43;1}{2} $$ 若果查找失败，则 $ASL=n&#43;1$
总体上，该算法时间复杂度为 $O(n)$
优化思路 1.如果使得表中的元素有序存放……，可以构造出一棵查找判定树
此时，查找失败时$ASL=\frac{1&#43;2&#43;&amp;hellip;&#43;n&#43;n}{n&#43;1}=\frac{n}{2}&#43;\frac{n}{n&#43;1}$
优点： 容易查找失败时ASL更小
2.如果各元素被查找的概率不同……，可以把概率大的靠前
优点： 容易查找成功时ASL更小
折半查找  折半查找，又称“二分查找”，仅适用于有序的顺序表。
 针对升序排列的顺序表，代码实现如下
typedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int BinarySearch(SSTable L,int key){ int low=0,high=L.TableLen-1,mid; while (low&amp;lt;=high) { mid=(low&#43;high)/2; if (L.'><title>查找算法相关</title>
<link rel='canonical' href='https://www.fintinger.site/p/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/'>
<link rel="stylesheet" href="/scss/loadingPage.css">


<link rel="stylesheet" href="/scss/style.min.css">

<link rel="stylesheet" href="/scss/external/tailwind.min.css">



<link rel="stylesheet" href="/scss/mobtoc.min.css"><meta property='og:title' content='查找算法相关'>
<meta property='og:description' content='顺序查找 typedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int Seq_Search(SSTable ST,int key){ ST.elem[0]=key; int i; for (i = ST.TableLen;ST.elem[i]!=key ; i--) {}//从后往前查找，最终返回下标i  return i;//返回0说明没找到 } 效率分析 对于长度为n的顺序表，如果查找成功 $$ ASL={\frac{1&#43;2&#43;&amp;hellip;&#43;n}{n}}=\frac{n&#43;1}{2} $$ 若果查找失败，则 $ASL=n&#43;1$
总体上，该算法时间复杂度为 $O(n)$
优化思路 1.如果使得表中的元素有序存放……，可以构造出一棵查找判定树
此时，查找失败时$ASL=\frac{1&#43;2&#43;&amp;hellip;&#43;n&#43;n}{n&#43;1}=\frac{n}{2}&#43;\frac{n}{n&#43;1}$
优点： 容易查找失败时ASL更小
2.如果各元素被查找的概率不同……，可以把概率大的靠前
优点： 容易查找成功时ASL更小
折半查找  折半查找，又称“二分查找”，仅适用于有序的顺序表。
 针对升序排列的顺序表，代码实现如下
typedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int BinarySearch(SSTable L,int key){ int low=0,high=L.TableLen-1,mid; while (low&amp;lt;=high) { mid=(low&#43;high)/2; if (L.'>
<meta property='og:url' content='https://www.fintinger.site/p/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/'>
<meta property='og:site_name' content='Archai &#39;s blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='数据结构' /><meta property='article:tag' content='顺序查找' /><meta property='article:tag' content='折半查找' /><meta property='article:tag' content='B树' /><meta property='article:tag' content='散列查找' /><meta property='article:published_time' content='2021-06-06T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2021-06-06T00:00:00&#43;00:00'/><meta property='og:image' content='https://www.fintinger.site/img/defaultImg.jpg' />
<meta name="twitter:title" content="查找算法相关">
<meta name="twitter:description" content="顺序查找 typedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int Seq_Search(SSTable ST,int key){ ST.elem[0]=key; int i; for (i = ST.TableLen;ST.elem[i]!=key ; i--) {}//从后往前查找，最终返回下标i  return i;//返回0说明没找到 } 效率分析 对于长度为n的顺序表，如果查找成功 $$ ASL={\frac{1&#43;2&#43;&amp;hellip;&#43;n}{n}}=\frac{n&#43;1}{2} $$ 若果查找失败，则 $ASL=n&#43;1$
总体上，该算法时间复杂度为 $O(n)$
优化思路 1.如果使得表中的元素有序存放……，可以构造出一棵查找判定树
此时，查找失败时$ASL=\frac{1&#43;2&#43;&amp;hellip;&#43;n&#43;n}{n&#43;1}=\frac{n}{2}&#43;\frac{n}{n&#43;1}$
优点： 容易查找失败时ASL更小
2.如果各元素被查找的概率不同……，可以把概率大的靠前
优点： 容易查找成功时ASL更小
折半查找  折半查找，又称“二分查找”，仅适用于有序的顺序表。
 针对升序排列的顺序表，代码实现如下
typedef struct{//查找表的数据结构（顺序表）  int *elem;//动态数组基址  int TableLen;//查找表长度 }SSTable; int BinarySearch(SSTable L,int key){ int low=0,high=L.TableLen-1,mid; while (low&amp;lt;=high) { mid=(low&#43;high)/2; if (L."><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://www.fintinger.site/img/defaultImg.jpg' />
    <link rel="shortcut icon" href="https://gitee.com/fintinger/figure-bed/raw/master//images/20210530080206.ico" />

  </head>
  <body style="overflow-y: hidden" class="
    article-page has-toc
">
    <div
      style="
        background: url('https://gitee.com/fintinger/figure-bed/raw/master//images/20210821130928.jpg')
          center/cover;
      "
      class="
        welcome_page
        w-full
        h-screen
        shadow-md
        flex flex-col
        justify-center
        items-center
      "
    >
      <div
        style="user-select: none"
        class="
          h-max
          xl:w-max
          py-10
          xl:py-32
          px-32
          xl:px-96
          bg-gray-100
          rounded-2xl
          shadow-2xl
          flex flex-col
          justify-center
          relative
          mb-10
        "
      >
        <span
          class="
            absolute
            w-16
            h-16
            bg-purple-200 bg-opacity0
            top-14
            right-14
            rounded-full
            text-center
            border-2 border-purple-600 border-opacity-10
            leading-loose
            text-3xl
            animate-pulse
          "
          >😋</span
        >
        <div class="flex flex-col items-center space-y-8 font-sans">
          <div
            style="
              background: url('https://gitee.com/fintinger/figure-bed/raw/master//images/20210803221048.jpeg')
                center/cover;
            "
            class="w-44 h-44 rounded-full"
          ></div>
          <h1 class="text-6xl font-semibold">ARCHAI</h1>
          <p style="margin-top: 7px" class="text-xl text-gray-500">
            Undergraduate / Rookie
          </p>
          <div class="bg-purple-600 px-5 py-3 rounded-md cursor-pointer">
            <a href="#main_content" class="text-white hover:text-white"
              >Read more</a
            >
          </div>
        </div>
      </div>
      <footer class="h-1/5 flex flex-col justify-end">
        <a href="#main_content">
          <svg
            class="animate-bounce"
            t="1629475731927"
            class="icon"
            viewBox="0 0 1024 1024"
            version="1.1"
            xmlns="http://www.w3.org/2000/svg"
            p-id="2357"
            width="80"
            height="80"
          >
            <path
              d="M896.32 336.992 523.648 709.664c-0.064 0.064-0.16 0.064-0.192 0.128-0.064 0.064-0.064 0.128-0.128 0.192-2.752 2.752-6.304 4.032-9.952 4.32-0.48 0.032-0.896 0.256-1.376 0.256-0.48 0-0.896-0.192-1.376-0.256-3.648-0.288-7.2-1.568-9.952-4.32-0.064-0.064-0.064-0.128-0.128-0.192-0.064-0.064-0.16-0.064-0.192-0.128L127.68 336.992c-6.432-6.432-6.592-16.704-0.32-22.976 6.24-6.24 16.512-6.112 22.976 0.32L512 676.064 873.696 314.368c6.432-6.432 16.704-6.592 22.976-0.32C902.912 320.288 902.752 330.56 896.32 336.992z"
              p-id="2358"
              fill="#dbdbdb"
            ></path>
          </svg>
        </a>
      </footer>
    </div>

    <div
      class="
        loading-page
        w-full
        h-full
        z-50
        fixed
        top-0
        text-purple-900
        flex
        justify-center
        items-center
      "
    >
      <div class="load-3">
        <div class="line"></div>
        <div class="line"></div>
        <div class="line"></div>
      </div>
    </div>
    <div id="main_content" class="main_content">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "light");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div
        class="container main-container flex 
    
        extended
    
"
      >
    
        <div id="article-toolbar">
            <a href="https://www.fintinger.site" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E5%90%8E%E7%AB%AF/" >
                后端
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/">查找算法相关</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jun 06, 2021</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    2 min read
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <h2 id="顺序查找">顺序查找</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span><span class="c1">//查找表的数据结构（顺序表）
</span><span class="c1"></span>    <span class="kt">int</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span><span class="c1">//动态数组基址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">TableLen</span><span class="p">;</span><span class="c1">//查找表长度
</span><span class="c1"></span><span class="p">}</span><span class="n">SSTable</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">Seq_Search</span><span class="p">(</span><span class="n">SSTable</span> <span class="n">ST</span><span class="p">,</span><span class="kt">int</span> <span class="n">key</span><span class="p">){</span>
    <span class="n">ST</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">key</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ST</span><span class="p">.</span><span class="n">TableLen</span><span class="p">;</span><span class="n">ST</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="n">key</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{}</span><span class="c1">//从后往前查找，最终返回下标i
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">i</span><span class="p">;</span><span class="c1">//返回0说明没找到
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="效率分析">效率分析</h3>
<p>对于长度为n的顺序表，如果<u>查找成功</u>
$$
ASL={\frac{1+2+&hellip;+n}{n}}=\frac{n+1}{2}
$$
若果查找失败，则 $ASL=n+1$</p>
<p>总体上，该算法时间复杂度为 $O(n)$</p>
<h3 id="优化思路">优化思路</h3>
<p>1.<span style="background-color:#fff006">如果使得表中的元素有序存放……</span>，可以构造出一棵查找判定树</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210602101845.png" style="zoom:33%;" /></p>
<p>此时，查找失败时$ASL=\frac{1+2+&hellip;+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}$</p>
<p><strong>优点：</strong> <span style="color:#e01">容易查找失败时ASL更小</span></p>
<p>2.<span style="background-color:#fff006">如果各元素被查找的概率不同……</span>，可以把概率大的靠前</p>
<p><strong>优点：</strong> <span style="color:#e01">容易查找成功时ASL更小</span></p>
<h2 id="折半查找">折半查找</h2>
<blockquote>
<p>折半查找，又称“二分查找”，仅适用于<strong>有序的顺序表</strong>。</p>
</blockquote>
<p><span style="color:#e01">针对升序排列的顺序表</span>，代码实现如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span><span class="c1">//查找表的数据结构（顺序表）
</span><span class="c1"></span>    <span class="kt">int</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span><span class="c1">//动态数组基址
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">TableLen</span><span class="p">;</span><span class="c1">//查找表长度
</span><span class="c1"></span><span class="p">}</span><span class="n">SSTable</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">BinarySearch</span><span class="p">(</span><span class="n">SSTable</span> <span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">key</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">high</span><span class="o">=</span><span class="n">L</span><span class="p">.</span><span class="n">TableLen</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">mid</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">low</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">==</span><span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">key</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">.</span><span class="n">elem</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">&gt;</span><span class="n">key</span><span class="p">)</span><span class="c1">//从前半部分继续查找
</span><span class="c1"></span>            <span class="n">high</span><span class="o">=</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">else</span><span class="c1">//从后半部分继续查找
</span><span class="c1"></span>            <span class="n">low</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="折半查找判定树">折半查找判定树</h3>
<p>对于一个给定的有序顺序表，</p>
<p>若其中元素个数为奇数个，则折半后构造出的判定树满足数量关系“左子树=右子树”；</p>
<p>若元素个数为偶数个，则根据$mid=\left \lfloor \frac{low+high}{2} \right \rfloor$,即<span style="color:#e01;">mid向下取整</span>，此时有”左子树=右子树-1“</p>
<p>故，不考虑失败结点，折半查找二叉树中满足 <span style="background-color:#fff006;">右子树结点数-左子树结点数=0或1</span>，因此对于<strong>编号</strong>为1~16的元素，不考虑失败结点，构造其折半查找判定树应该为：</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210602111935.png" style="zoom:30%;" /></p>
<p><strong>特征：</strong></p>
<p>① 折半查找判定树一定是平衡二叉树(AVL)；</p>
<p>②判定树结点的关键字满足 左&lt;中&lt;右，因此满足二叉排序树(BST)；</p>
<p>③ 失败结点有n+1个（等于成功结点的空链域数量）</p>
<h3 id="效率分析-1">效率分析</h3>
<p>由于折半查找判定树的树高不超过$\left \lceil \log_2(n+1) \right \rceil$，因此</p>
<p>查找失败|成功的情况下，$ASL \leq n$</p>
<p>其时间复杂度为$O(\log_2n)$</p>
<h2 id="分块查找">分块查找</h2>
<blockquote>
<p>分块查找最大的特征就是“块内无序，块间有序”。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//定义分块的索引表
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">maxValue</span><span class="p">;</span><span class="c1">//块中最大值
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">low</span><span class="p">,</span><span class="n">high</span><span class="p">;</span><span class="c1">//块在顺序表中的起始和结束地址
</span><span class="c1"></span><span class="p">}</span><span class="n">Index</span><span class="p">;</span>
<span class="c1">//顺序表存储实际元素
</span><span class="c1"></span><span class="kt">int</span> <span class="n">List</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</code></pre></div><h3 id="算法思想">算法思想</h3>
<p>对于给定的一串元素，整体上可能是无序的，但是如果按照最大有序序列划分之后，各块内就变得有序了。这样我们就可以根据分好的块建立的索引来快速定位key所在的区间。</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210603104602.png" style="zoom:50%;" /></p>
<p>分块查找，又称索引顺序查找，算法过程如下：</p>
<p>①在索引表中确定待查记录所属的分块（可顺序、可折半）</p>
<p>💥<span style="background-color:#fff006">注意在索引表中折半查找时，如果key没有直接等于maxValue，那么根据二分查找算法，当low&gt;high时，需要在low指向的块内继续进行查找</span></p>
<p>②在块内顺序查找</p>
<h3 id="查找效率分析">查找效率分析</h3>
<p>只考虑特殊情况，假设<span style="color:#e01">长度为n的表被均匀地分成b块，每块s个元素</span>&gt;，那么：</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210603110155.png" style="zoom: 80%;" /></p>
<p>设索引表和块内的平均查找长度分别为$L_I,L_S$，则整个查找过程的平均查找长度
$$
ASL=L_I+L_S
$$
具体地，如果<u>对索引表</u>采用<span style="background:#fff006">顺序查找</span>的方式：</p>
<p>$L_I={\frac{1+2+&hellip;+b}{b}}=\frac{b+1}{2}$</p>
<p>$L_S={\frac{1+2+&hellip;+s}{s}}=\frac{s+1}{2}$</p>
<p>则$ASL=\frac{s^2+2s+n}{2s}$，当$s=\sqrt{n}$ 时，$ASL_{min}=\sqrt{n}+1$</p>
<p>如果采用<span style="background:#fff006">折半查找</span>的方式：</p>
<p>$ASL=\left \lceil \log_2(b+1) \right \rceil+\frac{s+1}{2}$</p>
<h3 id="优化思路-1">优化思路</h3>
<p>如果插入某个元素，顺序表方式复杂度太高，故可采用链式存储的方式存储数据元素。</p>
<h2 id="b树">B树</h2>
<blockquote>
<p>B树，又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。</p>
</blockquote>
<p>对于一个<span style="color:#e01">m阶B树</span>其核心特征如下：</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210603115805.png" alt=""  /></p>
<h3 id="b树高度">B树高度</h3>
<blockquote>
<p>对于B树的高度，一般<span style="color:#e01;">不包括叶结点（失败的结点）</span></p>
</blockquote>
<h4 id="最小高度">最小高度</h4>
<p>为使得<u>有n个关键字的m阶B树</u>有最小高度，那么<u>每个结点应该尽可能地满</u>，有m-1个关键字，m个分叉，则有</p>
<p>$n\leq(m-1)(1+m+m^2+&hellip;+m^{h-1})=m^h-1$  可以得到，<span style="border:3px dashed #e01;padding:3px;">$h\geq \log_m(n+1)$</span></p>
<h4 id="最大高度">最大高度</h4>
<p>方式一：</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210603115918.png" alt=""  /></p>
<p>方式二：</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210603115945.png" alt=""  /></p>
<h3 id="插入删除操作">插入删除操作</h3>
<p style="border:3px dashed #e01;padding:2px;display:table;padding:5px 10px;">核心要求：</br>    ①对m阶B树除根节点外，结点关键字个数 m/2 -1 ≤ n ≤ m-1</n></br>
②子树0<关键字1<子树1<关键字2<子树2<...</p>
<h4 id="插入操作">插入操作</h4>
<p>新元素一定是插入到最底层“终端节点”，用“查找”来确定插入位置</p>
<p>在插入key后，若导致<strong>原结点关键字数超过上限</strong>，则从<strong>中间位置（m/2上取整）<strong>将其中的关键字</strong>分为两部分</strong>，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（m/2）的结点插入原结点的父结点。</p>
<p>若此时导致<strong>其父结点的关键字个数也超过了上限</strong>，则<strong>继续</strong>进行这种分裂操作，直至这个过程传到根结点为止，进而导致<strong>B树高度增1</strong>。</p>
<p>下图分别演示两种关键字超出结点上限的情况</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605154812.gif" alt="普通结点溢出"  /></p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605154837.gif" alt="根节点溢出"  /></p>
<h4 id="删除操作">删除操作</h4>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605155708.png" alt=""  /></p>
<h3 id="b树-1">B+树</h3>
<blockquote>
<p>有类似分块查找，上层保存下层结点中的最大值，但又保存了B树的一些特性</p>
</blockquote>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605160212.png" alt=""  /></p>
<p>一棵<span style="color:#e01">m阶B+树</span>满足以下条件：</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605160450.png" alt=""  /></p>
<h4 id="查找">查找</h4>
<p><span style="color:#e01">B+树中，无论查找成功与否，最终一定要走到最下面一层结点。</span></p>
<p>可以从根节点出发逐层查找，也可以借助指针p进行顺序查找</p>
<h4 id="对比b树">对比B树</h4>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605161703.png" alt=""  /></p>
<h2 id="散列查找">散列查找</h2>
<blockquote>
<p>散列表(Hash Table)，又称哈希表。是一种数据结构，特点是：数据元素的关键字与其存储地址直接相关。</p>
</blockquote>
<h3 id="相关概念">相关概念</h3>
<p><strong>同义词：</strong> 若不同的关键字通过散列函数映射到同一个值，则称它们为“同义词”</p>
<p><strong>冲突：</strong> 通过散列函数确定的位置已经存放了其他元素，则称这种情况为“冲突”</p>
<p><strong>哈希函数：</strong> 关键字与存放地址之间的转换函数。</p>
<p>**查找长度： **在查找运算中，需要对比关键字的次数称为查找长度。可能为0。</p>
<p>**装填因子：**对一个有n个关键字形成的长度为l的散列表，其装填因子 $\alpha=\frac{n}{l}$，表示的是查找失败时的平均查找长度ASL（当查找长度可为0的时）。装填因子越大说明散列表越满。</p>
<h3 id="处理冲突的方法">处理冲突的方法</h3>
<h4 id="1拉链法链接法或链地址法">1.拉链法(链接法或链地址法)</h4>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605170355.png" alt=""  /></p>
<h4 id="2开放定址法">2.开放定址法</h4>
<p>所谓开放定址法，是指可存放新表项的空闲地址既向它的<strong>同义词表项开放</strong>，又向它的<strong>非同义词表开放</strong>。其数学递推公式为：</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605171135.png" alt=""  /></p>
<p>其中，<em>i=0,1,2,&hellip;,k(k ≤ m-1)</em>，m表示<span style="color:#e01">散列表长</span>；$d_i$为<span style="color:#e01">增量序列</span>；i可理解为“第i次发生冲突”</p>
<p>对于增量序列$d_i$，有三种方法确定：①线性探测法；②平方探测法；③伪随机序列法</p>
<h5 id="线性探测法">①线性探测法</h5>
<p><span style="background:#dedede;padding:5px">$d_i$=0,1,2,3，&hellip;  ，m-1；即发生冲突时，每次往后探测相邻的<u>下一个单元是否为空</u></span></p>
<p>例如，有一堆数据元素，关键字分别为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数H（key）=key%13，</p>
<p>在存放1时，由于 1%13=1，但位置1处已经存在14，因此会后移一位存放到$H_1$=(1+$d_1$)%16=2的位置:</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210605173556.png" alt=""  /></p>
<p><strong>查找</strong></p>
<p>对于一个给定的key，通过开放定址法给出的递推公式确定其位置，若冲突，则寻找下一个位置，直至找到或遇到空地址失败为止。值得注意的是，在计算平均查找长度时，<u>空位置的比较也记作一次</u>，此外<span style="background:#fff006">如果能够越早遇到空位置，就能越早确定查找失败。</span></p>
<p><strong>删除</strong></p>
<p>删除操作不能简单地将某位置置为空（若置为空，将截断在它之后填⼊ 散列表的同义词结点的查找路径，可能导致查找操作误判），而应该<span style="background:#fff006">做⼀个“删除标记”，进⾏逻辑删除</span>。</p>
<p><strong>平均查找长度</strong></p>
<p>对于下图中的散列表{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数H（key）=key%13</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210606154801.png" alt=""  /></p>
<p>成功：</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210606154803.png" alt=""  /></p>
<p>失败：</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210606154809.png" alt=""  /></p>
<p>如果通过递推式映射到0的位置，只需1次对比</p>
<p>如果是1的位置，需要1,2,3&hellip;13，总共13次对比</p>
<p>如果是2的位置，需要2,3，&hellip; 13，总共12次对比</p>
<p>&hellip;&hellip;</p>
<p><span style="padding:5px;border:2px dashed #e01">线性探测法很容易造成同义词、⾮同义词的“聚集（堆积）”现象，严重影响查找效率</span></p>
<h5 id="平方探测法">②平方探测法</h5>
<p><span style="background:#dedede;padding:5px">$d_i=0^2,1^2，-1^2,2^2，-2^2&hellip;k^2,-k^2$；称为平方探测法，又称二次探测法，其中k≤m/2.</span></p>
<p><strong>注意：</strong> 散列表⻓度m必须是⼀个可以表示成4j + 3的素数，才能探测到所有位置&mdash;&mdash;《数论》</p>
<p><img src="https://gitee.com/fintinger/figure-bed/raw/master//images/20210606154815.png" alt=""  /></p>
<p>如图，可见，当表长为8时，没有探测到整个表。</p>
<h5 id="伪随机序列法">③伪随机序列法</h5>
<p><span style="background:#dedede;padding:5px">di 是⼀个伪随机序列，如 di= 0, 5, 24, 11, …</span></p>
<h4 id="3再散列法再哈希">3.再散列法(再哈希)</h4>
<p>除了原始的散列函数 H(key) 之外，多准备⼏个散列函数， 当散列函数冲突时，⽤下⼀个散列函数计算⼀个新地址，直到不冲突为⽌。</p>
<h3 id="常见的散列函数">常见的散列函数</h3>
<blockquote>
<p>目标：<u>让不同关键字的冲突尽可能地少</u></p>
</blockquote>
<h4 id="1除留余数法">1.除留余数法</h4>
<p><em>H(key)= key % p</em></p>
<p>散列表表长为m，取一个<strong>不大于m但最接近或等于m的质数p</strong>，分布更均匀，冲突更少。参见《数论》</p>
<h4 id="2--直接定址法">2.  直接定址法</h4>
<p><em>H(key) = key 或 H(key) = a × key + b</em></p>
<p>其中，a和b是常数。这种方法计算最简单且不会产生冲突。它适合<strong>关键字的分布基本连续的情况</strong>，若关键字分布不连续，空位较多，则会造成存储空间的浪费。</p>
<p>例如：学生学号的保存</p>
<h4 id="3数字分析法">3.数字分析法</h4>
<p><em>选取数码分布较为均匀的若干位作为散列地址</em></p>
<p>设关键字是r进制数（如十进制数），而<strong>r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些</strong>，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时可选取数码分布较为均匀的若干位作为散列地址。这种方法<strong>适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数</strong>。</p>
<p>例如：对手机号码，可以设计后四位作为散列地址</p>
<h4 id="4平方取中法">4.平方取中法</h4>
<p><em>取关键字的平方值的中间几位作为散列地址。</em></p>
<p>具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于<strong>关键字的每位取值都不够均匀或均小于散列地址所需的位数。</strong></p>
<p>例：要存储整个学校的学生信息，以“身份证号”作为关键字设计散列函数</p>
<blockquote>
<p>散列查找是“空间换时间”的算法，在散列表设计合理的情况下，散列表越长，冲突概率越低。</p>
</blockquote>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
        
            <a href="/tags/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/">顺序查找</a>
        
            <a href="/tags/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/">折半查找</a>
        
            <a href="/tags/b%E6%A0%91/">B树</a>
        
            <a href="/tags/%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE/">散列查找</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="has-image">
    <a href="/p/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3/">
        
        
            <div class="article-image">
                
                    <img src="https://picsum.photos/seed/waibupaixu/640/360" loading="lazy" data-key="" data-hash="https://picsum.photos/seed/waibupaixu/640/360"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">外部排序相关</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/">
        
        
            <div class="article-image">
                
                    <img src="https://picsum.photos/seed/paixu/640/360" loading="lazy" data-key="" data-hash="https://picsum.photos/seed/paixu/640/360"/>
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">排序算法相关</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/">
        
        

        <div class="article-details">
            <h2 class="article-title">图的存储</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8/">
        
        

        <div class="article-details">
            <h2 class="article-title">图的应用</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/">
        
        

        <div class="article-details">
            <h2 class="article-title">图的遍历</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
     
        
    <script src='//cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js'></script>
<div id="waline" class="waline-container"></div>
<style>
    .waline-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
    .waline-container .vcount {
        color: var(--card-text-color-main);
    }
</style><script>
    
    new Waline({"avatar":"robohash","dark":"html[data-scheme=\"dark\"]","el":"#waline","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/qq","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tieba","https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/tw-emoji"],"highlight":true,"locale":{"admin":"Admin"},"placeholder":"说点什么༼ つ ◕_◕ ༽つ","requiredMeta":["name","email","url"],"serverURL":"https://waline-q3l7of5hj-fintinger.vercel.app/","visitor":true});
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2018 - 
        
        2021 Archai &#39;s blog
    </section>
    
    <section class="powerby">
        
            Archai <br/>
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.5.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>

    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >
</main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#顺序查找">顺序查找</a>
      <ol>
        <li><a href="#效率分析">效率分析</a></li>
        <li><a href="#优化思路">优化思路</a></li>
      </ol>
    </li>
    <li><a href="#折半查找">折半查找</a>
      <ol>
        <li><a href="#折半查找判定树">折半查找判定树</a></li>
        <li><a href="#效率分析-1">效率分析</a></li>
      </ol>
    </li>
    <li><a href="#分块查找">分块查找</a>
      <ol>
        <li><a href="#算法思想">算法思想</a></li>
        <li><a href="#查找效率分析">查找效率分析</a></li>
        <li><a href="#优化思路-1">优化思路</a></li>
      </ol>
    </li>
    <li><a href="#b树">B树</a>
      <ol>
        <li><a href="#b树高度">B树高度</a>
          <ol>
            <li><a href="#最小高度">最小高度</a></li>
            <li><a href="#最大高度">最大高度</a></li>
          </ol>
        </li>
        <li><a href="#插入删除操作">插入删除操作</a>
          <ol>
            <li><a href="#插入操作">插入操作</a></li>
            <li><a href="#删除操作">删除操作</a></li>
          </ol>
        </li>
        <li><a href="#b树-1">B+树</a>
          <ol>
            <li><a href="#查找">查找</a></li>
            <li><a href="#对比b树">对比B树</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#散列查找">散列查找</a>
      <ol>
        <li><a href="#相关概念">相关概念</a></li>
        <li><a href="#处理冲突的方法">处理冲突的方法</a>
          <ol>
            <li><a href="#1拉链法链接法或链地址法">1.拉链法(链接法或链地址法)</a></li>
            <li><a href="#2开放定址法">2.开放定址法</a></li>
            <li><a href="#3再散列法再哈希">3.再散列法(再哈希)</a></li>
          </ol>
        </li>
        <li><a href="#常见的散列函数">常见的散列函数</a>
          <ol>
            <li><a href="#1除留余数法">1.除留余数法</a></li>
            <li><a href="#2--直接定址法">2.  直接定址法</a></li>
            <li><a href="#3数字分析法">3.数字分析法</a></li>
            <li><a href="#4平方取中法">4.平方取中法</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

      </div>
      <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script type="text/javascript" src="/js/clipboard/clipbordComplete.js" defer></script>
<script type="text/javascript" src="/js/loadingPage.js" defer></script>
<script type="text/javascript" src="/js/welcomePage.js" defer></script>
<script type="text/javascript" src="/js/mobToc.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>


      <div class="mobtoc">
        <ul></ul>
      </div>

      <div class="fixedEls">
        <div id="goTop"></div>
        <div class="show_mobToc"><svg t="1631963864136" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2699" width="100%" height="100%"><path d="M918.507 443.947H104.64c-37.547 0-68.16 30.72-68.16 68.16 0 37.546 30.72 68.16 68.16 68.16h813.867c37.546 0 68.16-30.72 68.16-68.16s-30.72-68.16-68.16-68.16z m-0.32 306.88H104.32c-37.547 0-68.16 30.72-68.16 68.16 0 37.546 30.72 68.16 68.16 68.16h813.867c37.546 0 68.16-30.72 68.16-68.16 0-37.547-30.614-68.16-68.16-68.16z m1.066-610.667H105.387c-37.547 0-68.16 30.72-68.16 68.16 0 37.547 30.72 68.16 68.16 68.16h813.866c37.547 0 68.16-30.72 68.16-68.16 0-37.547-30.72-68.16-68.16-68.16z" fill="#ededed" p-id="2700"></path></svg></div>
      </div>
    </div>
  </body>
</html>
