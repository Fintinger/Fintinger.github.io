<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Posts | Archai's home</title>
<meta name=keywords content>
<meta name=description content="Posts - Archai's home">
<meta name=author content="Archai">
<link rel=canonical href=https://www.fintinger.site/post/>
<meta name=google-site-verification content="XYZabc">
<meta name=yandex-verification content="XYZabc">
<meta name=msvalidate.01 content="XYZabc">
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style>
<link rel=preload href=https://gitee.com/fintinger/figure-bed/raw/master//images/20210530080206.ico as=image>
<link rel=icon href=https://gitee.com/fintinger/figure-bed/raw/master//images/20210530080206.ico>
<link rel=icon type=image/png sizes=16x16 href=https://www.fintinger.site/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://www.fintinger.site/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://www.fintinger.site/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://www.fintinger.site/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<link rel=alternate type=application/rss+xml href=https://www.fintinger.site/post/index.xml>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Posts">
<meta property="og:description" content>
<meta property="og:type" content="website">
<meta property="og:url" content="https://www.fintinger.site/post/"><meta property="og:image" content="https://gitee.com/fintinger/figure-bed/raw/master//images/20210803221048.jpeg"><meta property="og:site_name" content="Archai's home">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://gitee.com/fintinger/figure-bed/raw/master//images/20210803221048.jpeg">
<meta name=twitter:title content="Posts">
<meta name=twitter:description content>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://www.fintinger.site/post/"}]}</script>
</head>
<body class=list id=top>
<script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://www.fintinger.site accesskey=h title="Home (Alt + H)">
<img src=https://gitee.com/fintinger/figure-bed/raw/master//images/20210530080206.ico alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://www.fintinger.site/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://www.fintinger.site/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://www.fintinger.site/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://www.fintinger.site/archives/ title=Archives>
<span>Archives</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<header class=page-header><div class=breadcrumbs><a href=https://www.fintinger.site>Home</a></div>
<h1>Posts</h1>
</header>
<article class=post-entry>
<header class=entry-header>
<h2>寻址方式与存储模式
</h2>
</header>
<section class=entry-content>
<p>寻址方式 基本寻址方式 特 征 优 点 缺 点 备 注 隐含寻址 操作数的存放地由操作码决定 立即寻址 操作数直接在指令中 加快执行速度 增加指令长度，不方便修改操作数 适用提供常数，设定初始值 寄存器寻址 操作数在指令指定的寄存器中 方便修改，访问寄存器加快指令执行，缩短指令长度，编程更灵活 直接寻址 操作数地址在指令中，操作数在主存单元中 指令字较长，不方便地址修改 间接寻址 操作数地址的地址在指令中，操作数在主存中 方便修改指针，编程更灵活 访问两次主存获取操作数，降低执行速度 形式地址，有效地址EA(=操作数地址) 寄存器间接寻址 操作数地址在指令指定的寄存器中，操作数在主存单元中 压缩指令长度，修改寄存器内容就可以修改主存地址指针 方便编写循环程序 相对寻址 操作数地址由PC和指令提供的地址偏移量决定,操作数在主存单元中 EA=PC+D，适用与地址无关的程序设计 基址寻址 操作数地址由基址寄存器(RB)和指令提供的地址偏移量决定，操作数在主存单元中 缩短指令长度，扩大寻址空间 大型计算机，用户的逻辑地址→主存的物理地址，EA=(RB)+D 变址寻址 操作数地址由变址寄存器(RI)和指令提供的地址偏移量决定，操作数在主存单元中 寻址到操作数RI内容(地址)自动修改，EA=(RI)+D 堆栈寻址 寻址方式由指令操作码决定 适用涉及堆栈操作的指令，EA=(SP) 存储模式 “按字节编址” 主存将一个存储单元定为8位，即一个字节，这称为按字节编址的存储器...</p>
</section>
<footer class=entry-footer><span title="2021-07-22 00:00:00 +0000 UTC">July 22, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Archai</footer>
<a class=entry-link aria-label="post link to 寻址方式与存储模式" href=https://www.fintinger.site/post/2021/07/22/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>外部排序相关
</h2>
</header>
<section class=entry-content>
<p>外部排序 由于数据元素太多，无法一次全部读入内存进行内部排序，这是就要通过外部排序来解决
1.外排原理 (拿二路归并举例)
如图，对于在磁盘中分块存放的数据，每块存入三个元素，共16块
在内存中建立三个缓冲区输出缓冲区、输入缓冲区1以及输入缓冲区2
1.1构造初始归并段 首先，依次地读入前两块数据，分别存入内存中的 缓冲区1、缓冲区2
将输入缓冲区1以及输入缓冲区2中存放的数据经过 内存中的二路归并排序(内排)后，将生成的有序的块经 输出缓冲区 写入磁盘 得到一个有序的归并段同样的，对剩余块进行同样的操作可以得到
1.2以归并段为单位进行归并 分别选取归并段1和2中较小的一块，依次读入至缓冲区1,2
内排之后，写入内存，注意，输入缓冲区1(或2)空缺后要立即在归并段1(或2)中读入新的块到其中进行归并排序（以保证输出缓冲区始终输出归并段中较小的元素）
最终，完成所有归并段的第一趟归并之后，会有
之后，4块成一个归并段，两两归并
……
最终。经过3趟归并，整体会变得有序！
2.优化思路 2.1时间开销分析 在整个排序过程中，时间开销分析如下
可以看到，
外部排序时间开销=读写外存的时间+内部排序所需时间+内部归并所需时间而读写外存时间是关键的时间开销，因此优化应该针对怎么减少读写外存的次数展开
而文件总块数无法优化，只能针对归并的趟数优化为此，我们需要采用多路归并来解决
2.3结论 2.4 优化思路一：采用多路归并 对上面的例子，如果采用四路归并
只需96次读写即可！！
2.5 优化思路二：减少初始归并段数量r 败者树 1.算法思想 构造 如图所示的树结构，叶节点对应（脑补）各归并段（假设共有8个归并段），分支结点记录败者来自哪个归并段，最后根节点记录冠军来自哪个归并段，并且将冠军输出，为这8个归并段中的最小值。
下轮选择冠军记录的那个归并段（归并段3）中的元素6，代替1的位置，如图，并依次向上的与各败者结点对比，胜则往上，败则留下，最终输出冠军
接下来，循环这个过程
2.效率分析 对于k路归并，第一次构造败者树需要对比关键字k-1次 有了败者树，选出最小元素，只需对比关键字次$\left \lceil \log_2k \right \rceil$
置换选择排序 1.算法思想 设初始待排文件为F，初始归并段输出文件为FO，内存工作区为WA,FO和WA的初始状态为空，WA可容纳w个记录。置换选择算法的步骤如下： 1）从F输入个记录到工作区WA。 2）从WA中选出其中关键字取最小值的记录，记为 MINIMAX记录3）将MINIMAX记录输出到FO中去。 4）若F不空，则从F输入下一个记录到WA中。 5）从w中所有关MINIMAX键字比记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。 6）重复3）~5），直至在A中选不 MININ出新的记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。 7）重复2）~6），直至WA为空。由此得到全部初始归并段。
最佳归并树 利用置换选择排序构造初始归并段，归并段长短不一
对于一个归并树，如图数字表示该归并段占多少个磁盘块。
每个初始归并段看作⼀个叶⼦结点，归并段的⻓度作为结点权值，则 上⾯👆这棵归并树的带权路径⻓度 WPL = 2*1 + (5+1+6+2) * 3 = 44...</p>
</section>
<footer class=entry-footer><span title="2021-06-10 00:00:00 +0000 UTC">June 10, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Archai</footer>
<a class=entry-link aria-label="post link to 外部排序相关" href=https://www.fintinger.site/post/2021/06/10/externalsort/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>排序算法相关
</h2>
</header>
<section class=entry-content>
<p>排序算法 平均时间复杂度 空间复杂度 稳定性 适用情况 插入排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序 希尔排序 $O(n^{1.3})$ O(1) 不稳定 冒泡排序 $O(n^2)$ O(1) 稳定 n较小，初始序列基本有序 快速排序 $O(n\log_2n)$ $O(nlog_2n)$ 不稳定 初始序列无序 简单选择排序 $O(n^2)$ O(1) 不稳定 n较小 堆排序 $O(n\log_2n)$ O(1) 不稳定 n较大或只排前几位 2-路归并排序 $O(n\log_2n)$ O(n) 稳定 n很大 链式基数排序 $O(d(n+rd))$ $O(rd)$ 稳定 n大，关键字值小 相关概念 1....</p>
</section>
<footer class=entry-footer><span title="2021-06-10 00:00:00 +0000 UTC">June 10, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Archai</footer>
<a class=entry-link aria-label="post link to 排序算法相关" href=https://www.fintinger.site/post/2021/06/10/sort/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>查找算法相关
</h2>
</header>
<section class=entry-content>
<p>顺序查找 typedef struct{//查找表的数据结构（顺序表） int *elem;//动态数组基址 int TableLen;//查找表长度 }SSTable; int Seq_Search(SSTable ST,int key){ ST.elem[0]=key; int i; for (i = ST.TableLen;ST.elem[i]!=key ; i--) {}//从后往前查找，最终返回下标i return i;//返回0说明没找到 } 效率分析 对于长度为n的顺序表，如果查找成功$$ ASL={\frac{1+2+…+n}{n}}=\frac{n+1}{2} $$ 若果查找失败，则 $ASL=n+1$
总体上，该算法时间复杂度为 $O(n)$
优化思路 1.如果使得表中的元素有序存放……，可以构造出一棵查找判定树
此时，查找失败时$ASL=\frac{1+2+…+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}$
优点： 容易查找失败时ASL更小2.如果各元素被查找的概率不同……，可以把概率大的靠前
优点： 容易查找成功时ASL更小折半查找 折半查找，又称“二分查找”，仅适用于有序的顺序表。
针对升序排列的顺序表，代码实现如下
typedef struct{//查找表的数据结构（顺序表） int *elem;//动态数组基址 int TableLen;//查找表长度 }SSTable; int BinarySearch(SSTable L,int key){ int low=0,high=L.TableLen-1,mid; while (low&lt;=high) { mid=(low+high)/2; if (L.elem[mid]==key) return key; else if(L....</p>
</section>
<footer class=entry-footer><span title="2021-06-06 00:00:00 +0000 UTC">June 6, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Archai</footer>
<a class=entry-link aria-label="post link to 查找算法相关" href=https://www.fintinger.site/post/2021/06/06/search/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>图的应用
</h2>
</header>
<section class=entry-content>
<p>一、最小生成树 📌什么是生成树？ 连通图的生成树是包含图中所有顶点的一个极小连通子图，通俗地讲，就是“边尽可能少，但需保持连通”。规律： 对于一个顶点数|V|=n的树，其生成树的边数|E|=n-1。如果将|E|+1，必然会形成回路；如果将|E|-1，则会成为非连通图。
📌什么是最小生成树？ 最小生成树，也称最小代价树(Minimum Spanning Tree，MST)
是带权连通无向图的生成树中边的权值之和最小的一棵树，联系实际问题不难理解其中“最小代价”的意味。Prim（普利姆算法），Kruskal（克鲁斯卡尔算法）就是寻找最小生成树的常用算法。
1.Prim（普利姆算法） 从某一顶点开始，每次将代价最小的新顶点纳入生成树，直至所有顶点都纳入为止。
图示 易知，此方法得到的最小生成子树是不唯一的。
代码实现 void MiniSpanTree_PRIMI(Graph G,int u){ //从顶点u出发找G的最小生成树 for (int i = 0; i &lt;G.vexnum; ++i) {//辅助数组初始化 if(i!=u){ closedge[i]={u,G.arcs[u][i]}; } } closedge[u].lowcost=0; for (int j = 0; j &lt; G.vexnum; j++) { k=minimum(closedge);//求生成树的下一个节点 cout&lt;&lt;cloedge[k].adjvex&lt;&lt;G.vex[k]; closedge[k].lowcost=0; for (int i = 0; i &lt; G.vexnum; i++) { if (G.arc[k][j].adj&lt;closedge[j].lowcost) { closedge[j]={G.vexs[k],G.arcs[k][j].adj}; } } } } 2....</p>
</section>
<footer class=entry-footer><span title="2021-06-04 00:00:00 +0000 UTC">June 4, 2021</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Archai</footer>
<a class=entry-link aria-label="post link to 图的应用" href=https://www.fintinger.site/post/2021/06/02/02_application/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>图的遍历
</h2>
</header>
<section class=entry-content>
<p>广度优先遍历（BFS） BFS(Breadth-First-Search)，参考对树的层序遍历
对上面的图从①出发进行BFS得到序列：
①②⑤ ⑥ ③⑦ ④⑧
若采用不同的储存结构，可能会得到不同的遍历结果（这个差异主要来自寻找邻接点的过程），对于邻接矩阵存储的图，由于邻接矩阵是唯一的，所以BFS序列也是唯一的；同理，邻接表存储的图BFS序列不唯一。
BFS算法 与树的层序遍历不同的是，由于图中存在回路，遍历过程中会出现重复访问的问题，故可构造visited数组，用来标记已访问过的数组。此外，还应针对非连通图做额外的判断，遍历完一个连通分量（极大连通子图）后，遍历查找visited数组中是否还存在未遍历的，如果有即为另一连通分量，继续调用BFS即可。
void BFS(Graph G,int v); bool visited[MAX_VERTEX_NUM]; SqQueue Q;//辅助队列 void BFSTraverse(Graph G){ //初始化visited数组 for (int i = 0; i &lt; G.vexnum; ++i) {//使下标从1开始 visited[i]=false; } //对非连通图的处理 for (int v = 0; v &lt; G.vexnum; ++v) { if (!visited[v]) BFS(G,v); } } //从顶点v出发广度优先遍历图G void BFS(Graph G,int v){ visit(v); visited[v]=true; EnQueue(Q,v);//顶点v入队列Q while(!isEmpty(Q)){ DeQueue(Q,v);//顶点v出队列Q for (w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))//处理v的所有邻接点 if (!...</p>
</section>
<footer class=entry-footer><span title="2021-06-03 00:00:00 +0000 UTC">June 3, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Archai</footer>
<a class=entry-link aria-label="post link to 图的遍历" href=https://www.fintinger.site/post/2021/06/02/01_traverse/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>图的存储
</h2>
</header>
<section class=entry-content>
<p>邻接矩阵 Vextex/Vertices 顶点; Martix 矩阵; Arc 弧.
代码实现 #define MaxVextexNum 100//容许存储的最大顶点数 typedef struct{ char Vex[MaxVextexNum]; //可以将定点之间的关系用int 类型01表示，也可定义为boolean/枚举类型，占空间更小 bool Edge[MaxVextexNum][MaxVextexNum]; int vexnum,arcnum;//顶点数和弧|边数 }MGraph; 即找度 根据邻接矩阵计算结点的度TD
无向图 有向图 $TD(V_i)$ 第i行（或i列）中非零元素的个数 $ID(V_i)$ : i行非零元素个数$OD(V_i)$: i列非零元素个数TD=ID+OD 对于带权图（网） #define MaxVextexNum 100//容许存储的最大顶点数 #define INIFINITY //宏定义，表示无穷 typedef char VextexType;//顶点 typedef int EdgeType;//权值 typedef struct{ VextexType Vex[MaxVextexNum]; EdgeType Edge[MaxVextexNum][MaxVextexNum]; int vexnum,arcnum; }MGraph; 复杂度 空间复杂度来自数组Vex[]跟Edge[]，故空间复杂度为$|V|+|V|^2=O(|V|^2)$，即为顶点数量的二次方，故此方法更适合存储稠密图，不然有较多浪费。...</p>
</section>
<footer class=entry-footer><span title="2021-06-02 00:00:00 +0000 UTC">June 2, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Archai</footer>
<a class=entry-link aria-label="post link to 图的存储" href=https://www.fintinger.site/post/2021/06/02/00_storage/></a>
</article>
<article class=post-entry>
<header class=entry-header>
<h2>AVL树
</h2>
</header>
<section class=entry-content>
<p>平衡二叉树是Adelson-Velsky和 Landis发明，故命名为AVL树。也称平衡二叉查找树。
✨特点： ①左子树&lt;根&lt;右子树； ②任一节点，左右子树高度之差不超过1.
平衡因子 $平衡因子=左子树高-右子树高$
AVL树的插入操作 AVL树插入新结点导致不平衡之后，只需将最小不平衡子树平衡，其他祖先结点会随之恢复平衡。
调整最小不平衡子树 1.LL 即在以A为根节点的树的左孩子B的左子树上插入新结点，导致A成为最小不平衡子树。
调整过程如下：
2.RR 即在以A为根节点的树的右孩子B的右子树上插入新结点，导致A成为最小不平衡子树。
调整过程如下：
3.LR 即在以A为根节点的树的左孩子B的右子树上插入新结点，导致A成为最小不平衡子树。
观察得知，所进行的调整就是保证$|平衡因子|&lt;=1$，因此若插入操作使得
左 - 右 > 1 => 右旋
右 - 左 > 1 =>左旋
而当进行了LR插入操作之后，导致以A为根节点的树 左-右>1，理应右旋但是，由上述结果可知，经过右旋之后：
可以看到，为了保证其左子树&lt;根&lt;右子树的特性，经过调整后，依然存在右-左>1的问题；
因此，对于LR型不能简单进行右旋调整，应该先将其转化为LL型 (左旋)，再进行右旋；
为此，我们需要将BR结点展开，之后旋转成为LL型插入
可以看到，展开后又出现两种插入情况CL&CR，但其实两者处理大同小异：
CR插入调整过程如下：
4.RL 即在以A为根节点的树的右孩子B的左子树上插入新结点，导致A成为最小不平衡子树。
参考LR型，其调整过程如下：
查找操作效率分析 Assuming that, $n_h$表示深度为h的平衡树中含有的最少结点，则
$n_0=0$,$n_1=1$,$n_2=2$…存在递归关系 $n_h=n_{h-1}+n_{h-2}+1$,即左右子树结点之和+根节点。
可以证明(AVL证明)，n个结点的平衡二叉树最大深度数量级为$\log_2n$，则其查找操作的复杂度为$O(\log_2n)$</p>
</section>
<footer class=entry-footer><span title="2021-05-23 00:00:00 +0000 UTC">May 23, 2021</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Archai</footer>
<a class=entry-link aria-label="post link to AVL树" href=https://www.fintinger.site/post/2021/05/23/avl/></a>
</article>
<footer class=page-footer>
<nav class=pagination>
<a class=prev href=https://www.fintinger.site/post/>« Prev Page</a>
<a class=next href=https://www.fintinger.site/post/page/3/>Next Page »</a>
</nav>
</footer>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://www.fintinger.site>Archai's home</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>